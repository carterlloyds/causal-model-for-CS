<!-- graph model editor -->
<link rel="icon" type="image/png" href="https://www.indeavor.com/wp-content/uploads/2020/05/favicon-75x75.png">
<style>
    /* Hard encapsulation: everything inside #causal-editor */
    #causal-editor,
    #causal-editor * {
        box-sizing: border-box !important;
        font-family: Arial, sans-serif !important;
    }

    #causal-editor {
        height: calc(100vh - 16px) !important;
        width: 100% !important;
        background: #ffffff !important;
        color: #111111 !important;
        margin: 8px !important;
    }

    #causal-editor a {
        color: #0056B3 !important;
        text-decoration: none !important;
    }

    #causal-editor a:hover {
        text-decoration: underline !important;
    }

    #causal-editor #app {
        display: flex !important;
        height: 100% !important;
        width: 100% !important;
    }

    #causal-editor #sidebar {
        width: 340px !important;
        min-width: 260px !important;
        max-width: 440px !important;
        border-right: 1px solid #dddddd !important;
        background: #f7f7f7 !important;
        padding: 12px !important;
        overflow-y: auto !important;
    }

    #causal-editor #main {
        flex: 1 !important;
        display: flex !important;
        flex-direction: column !important;
        padding: 8px !important;
        background: #ffffff !important;
    }

    #causal-editor #network {
        flex: 1 !important;
        min-height: 400px !important;
        border: 1px solid #cccccc !important;
        background: #ffffff !important;
    }

    #causal-editor h1,
    #causal-editor h2,
    #causal-editor h3,
    #causal-editor h4,
    #causal-editor h5,
    #causal-editor h6 {
        margin-top: 0 !important;
        margin-bottom: 6px !important;
        font-weight: 600 !important;
        color: #111111 !important;
    }

    #causal-editor h2 {
        font-size: 18px !important;
    }

    #causal-editor h3 {
        font-size: 14px !important;
        border-bottom: 1px solid #dddddd !important;
        padding-bottom: 2px !important;
    }

    #causal-editor label {
        font-size: 12px !important;
        display: block !important;
        margin-bottom: 3px !important;
        color: #333333 !important;
    }

    #causal-editor input[type="text"],
    #causal-editor input[type="file"],
    #causal-editor select,
    #causal-editor textarea {
        width: 100% !important;
        font-size: 12px !important;
        padding: 4px 6px !important;
        margin-bottom: 8px !important;
        border-radius: 3px !important;
        border: 1px solid #cccccc !important;
        background: #ffffff !important;
        color: #111111 !important;
        box-shadow: none !important;
        outline: none !important;
    }

    #causal-editor input[type="file"] {
        padding: 2px !important;
    }

    #causal-editor textarea {
        resize: vertical !important;
    }

    #causal-editor button {
        font-size: 12px !important;
        padding: 5px 8px !important;
        margin: 2px 0 !important;
        border-radius: 4px !important;
        border: 1px solid #999999 !important;
        background: #ffffff !important;
        color: #111111 !important;
        cursor: pointer !important;
        box-shadow: none !important;
        display: inline-block !important;
        line-height: 1.3 !important;
    }

    #causal-editor button.primary {
        background: #0056B3 !important;
        color: #ffffff !important;
        border-color: #00408a !important;
    }

    #causal-editor button.danger {
        background: #c0392b !important;
        color: #ffffff !important;
        border-color: #a5281b !important;
    }

    #causal-editor button:disabled {
        opacity: 0.5 !important;
        cursor: default !important;
    }

    #causal-editor .button-row {
        display: flex !important;
        flex-wrap: wrap !important;
        gap: 4px !important;
        margin-bottom: 8px !important;
    }

    #causal-editor .small {
        font-size: 11px !important;
        color: #555555 !important;
    }

    #causal-editor .inline-file {
        font-size: 11px !important;
        margin-bottom: 8px !important;
    }

    #causal-editor .tag-row {
        display: flex !important;
        flex-wrap: wrap !important;
        gap: 4px !important;
        margin-bottom: 4px !important;
    }

    #causal-editor .tag {
        padding: 4px 10px !important;
        border-radius: 999px !important;
        font-size: 11px !important;
        border: none !important;
        background: #cccccc !important;
        color: #ffffff !important;
        white-space: nowrap !important;
        font-weight: 600 !important;
        cursor: pointer !important;
        transition: opacity 0.2s !important;
    }

    #causal-editor .tag:hover {
        opacity: 0.85 !important;
    }

    #causal-editor .section {
        margin-bottom: 12px !important;
    }

    #causal-editor #selectedNodeSummary {
        font-size: 11px !important;
        padding: 4px !important;
        background: #eeeeee !important;
        border-radius: 4px !important;
        margin-bottom: 6px !important;
    }

    #causal-editor .view-state-indicator {
        font-size: 11px !important;
        padding: 6px 8px !important;
        border-radius: 4px !important;
        margin-bottom: 6px !important;
        background: #e8f4e8 !important;
        border-left: 3px solid #2ecc71 !important;
    }

    #causal-editor .view-state-indicator.isolated {
        background: #fff3e0 !important;
        border-left-color: #f39c12 !important;
    }

    #causal-editor #exportText {
        font-family: Menlo, Monaco, Consolas, "Courier New", monospace !important;
        font-size: 11px !important;
    }

    #causal-editor .type-label {
        display: flex !important;
        align-items: center !important;
        gap: 6px !important;
        font-size: 12px !important;
        margin-bottom: 2px !important;
    }

    #causal-editor .type-label input {
        margin: 0 !important;
        width: auto !important;
    }

    #causal-editor .filters {
        margin-top: 4px !important;
        margin-bottom: 4px !important;
    }

    #causal-editor #indeavor-logo {
        max-width: 160px !important;
        margin-bottom: 6px !important;
        display: block !important;
    }

    #causal-editor .type-item {
        display: flex !important;
        align-items: center !important;
        gap: 6px !important;
        margin-bottom: 4px !important;
        font-size: 12px !important;
    }

    #causal-editor .type-color-dot {
        width: 12px !important;
        height: 12px !important;
        border-radius: 50% !important;
        display: inline-block !important;
    }

    #causal-editor .type-delete-btn {
        font-size: 10px !important;
        padding: 2px 5px !important;
        margin: 0 !important;
    }

    #causal-editor .help-btn {
        font-size: 14px !important;
        padding: 2px 8px !important;
        border-radius: 50% !important;
        margin-left: 8px !important;
        vertical-align: middle !important;
    }

    #causal-editor .search-results {
        position: absolute !important;
        top: 100% !important;
        left: 0 !important;
        right: 0 !important;
        background: #ffffff !important;
        border: 1px solid #cccccc !important;
        border-top: none !important;
        border-radius: 0 0 3px 3px !important;
        max-height: 200px !important;
        overflow-y: auto !important;
        z-index: 100 !important;
        display: none !important;
    }

    #causal-editor .search-results.active {
        display: block !important;
    }

    #causal-editor .search-result-item {
        padding: 6px 8px !important;
        cursor: pointer !important;
        font-size: 12px !important;
        border-bottom: 1px solid #eeeeee !important;
        display: flex !important;
        align-items: center !important;
        gap: 8px !important;
    }

    #causal-editor .search-result-item:last-child {
        border-bottom: none !important;
    }

    #causal-editor .search-result-item:hover,
    #causal-editor .search-result-item.highlighted {
        background: #f0f0f0 !important;
    }

    #causal-editor .search-result-dot {
        width: 10px !important;
        height: 10px !important;
        border-radius: 50% !important;
        flex-shrink: 0 !important;
    }

    #causal-editor .search-result-label {
        flex: 1 !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
        white-space: nowrap !important;
    }

    #causal-editor .search-result-type {
        font-size: 10px !important;
        color: #888888 !important;
        flex-shrink: 0 !important;
    }

    #causal-editor .modal-overlay {
        display: none;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        background: rgba(0,0,0,0.5) !important;
        align-items: center !important;
        justify-content: center !important;
        z-index: 10000 !important;
    }

    #causal-editor .modal-overlay.visible {
        display: flex !important;
    }

    #causal-editor .modal-content {
        background: #ffffff !important;
        padding: 20px !important;
        border-radius: 8px !important;
        max-width: 500px !important;
        max-height: 80vh !important;
        overflow-y: auto !important;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3) !important;
    }

    #causal-editor .modal-content h3 {
        margin-top: 12px !important;
        border-bottom: none !important;
    }

    #causal-editor .modal-content h3:first-child {
        margin-top: 0 !important;
    }

    #causal-editor .modal-content ul {
        margin: 8px 0 !important;
        padding-left: 20px !important;
    }

    #causal-editor .modal-content li {
        margin-bottom: 4px !important;
        font-size: 12px !important;
    }

    #causal-editor .modal-content kbd {
        background: #eeeeee !important;
        border: 1px solid #cccccc !important;
        border-radius: 3px !important;
        padding: 1px 5px !important;
        font-family: monospace !important;
        font-size: 11px !important;
    }

    #causal-editor .modal-close {
        float: right !important;
        font-size: 20px !important;
        border: none !important;
        background: none !important;
        cursor: pointer !important;
        padding: 0 !important;
        margin: 0 !important;
        line-height: 1 !important;
    }

    #causal-editor .attr-item {
        display: flex !important;
        align-items: center !important;
        gap: 6px !important;
        margin-bottom: 4px !important;
        font-size: 12px !important;
    }

    #causal-editor .attr-item span {
        flex: 1 !important;
    }

    #causal-editor .attr-value-row {
        display: flex !important;
        align-items: center !important;
        gap: 6px !important;
        margin-bottom: 6px !important;
    }

    #causal-editor .attr-value-row label {
        min-width: 80px !important;
        margin-bottom: 0 !important;
        font-weight: 500 !important;
    }

    #causal-editor .attr-value-row input {
        flex: 1 !important;
        margin-bottom: 0 !important;
    }

    #causal-editor .rule-list {
        margin: 4px 0 8px 0 !important;
        max-height: 100px !important;
        overflow-y: auto !important;
    }

    #causal-editor .rule-item {
        display: flex !important;
        align-items: center !important;
        gap: 4px !important;
        font-size: 11px !important;
        padding: 2px 4px !important;
        background: #f5f5f5 !important;
        border-radius: 3px !important;
        margin-bottom: 3px !important;
    }

    #causal-editor .rule-item span {
        flex: 1 !important;
    }

    #causal-editor .rule-form {
        display: flex !important;
        align-items: center !important;
        gap: 4px !important;
        flex-wrap: wrap !important;
        font-size: 11px !important;
    }

    #causal-editor .rule-form select,
    #causal-editor .rule-form input[type="text"] {
        padding: 2px 4px !important;
        font-size: 11px !important;
        margin-bottom: 0 !important;
    }

    #causal-editor .small-btn {
        padding: 2px 8px !important;
        font-size: 12px !important;
        cursor: pointer !important;
    }

    #causal-editor .color-swatch {
        display: inline-block !important;
        width: 12px !important;
        height: 12px !important;
        border-radius: 2px !important;
        border: 1px solid #999 !important;
        vertical-align: middle !important;
    }

    @media (max-width: 900px) {
        #causal-editor #app {
            flex-direction: column !important;
        }
        #causal-editor #sidebar {
            width: 100% !important;
            max-height: 52vh !important;
            border-right: none !important;
            border-bottom: 1px solid #dddddd !important;
        }
        #causal-editor #main {
            padding: 4px !important;
        }
    }
</style>

<div id="causal-editor">
    <div id="app">
        <div id="sidebar">
            <img id="indeavor-logo" src="https://www.indeavor.com/wp-content/uploads/2024/09/indeavor-logo.svg" alt="Indeavor logo">
            <h2>Graph Model Editor <button id="btnHelp" class="help-btn">?</button></h2>

            <div id="typeLegend" class="tag-row">
                <!-- Dynamic type legend will be rendered here -->
            </div>

            <!-- Find Node -->
            <div class="section">
                <label for="nodeSearch">Find Node</label>
                <div style="position:relative;">
                    <input type="text" id="nodeSearch" placeholder="Type to search..." autocomplete="off">
                    <div id="searchResults" class="search-results"></div>
                </div>
            </div>

            <!-- Import / Export CSV -->
            <div class="section">
                <h3>Import / Export CSV</h3>
                <div class="inline-file">
                    <label for="importNodesFile">Upload nodes.csv (Node,Type,Attr1,Attr2,...):</label>
                    <input type="file" id="importNodesFile" accept=".csv,.txt">
                </div>
                <div class="inline-file">
                    <label for="importEdgesFile">Upload edges.csv (Node 1,Node 2,Attr1,Attr2,...):</label>
                    <input type="file" id="importEdgesFile" accept=".csv,.txt">
                </div>
                <div class="button-row">
                    <button id="btnImportCSV" class="primary">Import CSV Files</button>
                    <button id="btnClear">New / Clear Graph</button>
                </div>
                <div class="button-row">
                    <button id="btnExportNodesCSV">Download nodes.csv</button>
                    <button id="btnExportEdgesCSV">Download edges.csv</button>
                </div>
            </div>

            <!-- Manage Types -->
            <div class="section">
                <h3>Manage Types</h3>
                <div id="typeList">
                    <!-- Dynamic type list will be rendered here -->
                </div>
                <label for="newTypeName">Add new type:</label>
                <input type="text" id="newTypeName" placeholder="Type name...">
                <div class="button-row">
                    <button id="btnAddType" class="primary">Add Type</button>
                </div>
            </div>

            <!-- Manage Attributes -->
            <div class="section">
                <h3>Manage Attributes</h3>
                <label for="attrTargetType">Attribute applies to:</label>
                <select id="attrTargetType">
                    <option value="node">Nodes</option>
                    <option value="edge">Edges</option>
                </select>

                <div id="attrList">
                    <!-- Dynamic attribute list will be rendered here -->
                </div>

                <label for="newAttrName">Add new attribute:</label>
                <input type="text" id="newAttrName" placeholder="Attribute name...">
                <div class="button-row">
                    <button id="btnAddAttr" class="primary">Add Attribute</button>
                </div>
            </div>

            <!-- Style Rules -->
            <div class="section">
                <h3>Style Rules</h3>

                <div style="margin-bottom:10px;">
                    <strong>Node Shape Rules</strong>
                    <div id="nodeShapeRulesList" class="rule-list">
                        <div class="small">No shape rules defined.</div>
                    </div>
                    <div class="rule-form">
                        <select id="nodeShapeAttr">
                            <option value="">-- attribute --</option>
                        </select>
                        <span>=</span>
                        <input type="text" id="nodeShapeValue" placeholder="value" style="width:60px;">
                        <span>→</span>
                        <select id="nodeShapeShape">
                            <option value="dot">dot</option>
                            <option value="diamond">diamond</option>
                            <option value="star">star</option>
                            <option value="triangle">triangle</option>
                            <option value="triangleDown">triangleDown</option>
                            <option value="hexagon">hexagon</option>
                            <option value="square">square</option>
                            <option value="box">box</option>
                            <option value="ellipse">ellipse</option>
                        </select>
                        <button id="btnAddNodeShapeRule" class="small-btn">+</button>
                    </div>
                    <div class="small">Select attribute, enter value, choose shape, click <strong>+</strong> to add rule.</div>
                </div>

                <div>
                    <strong>Edge Color Rules</strong>
                    <div id="edgeColorRulesList" class="rule-list">
                        <div class="small">No color rules defined.</div>
                    </div>
                    <div class="rule-form">
                        <select id="edgeColorAttr">
                            <option value="">-- attribute --</option>
                        </select>
                        <span>=</span>
                        <input type="text" id="edgeColorValue" placeholder="value" style="width:60px;">
                        <span>→</span>
                        <input type="color" id="edgeColorColor" value="#ff0000" style="width:40px;height:24px;">
                        <button id="btnAddEdgeColorRule" class="small-btn">+</button>
                    </div>
                    <div class="small">Select attribute, enter value, pick color, click <strong>+</strong> to add rule.</div>
                </div>
            </div>

            <!-- Create Node -->
            <div class="section">
                <h3>Create Node</h3>
                <label for="createNodeLabel">Label</label>
                <input type="text" id="createNodeLabel" placeholder="New node label...">

                <label for="createNodeType">Type</label>
                <select id="createNodeType">
                    <option value="">-- select type --</option>
                </select>

                <div class="button-row">
                    <button id="btnAddNode" class="primary">Add Node</button>
                </div>
            </div>

            <!-- Edit Node -->
            <div class="section">
                <h3>Edit Node</h3>
                <div id="selectedNodeSummary">
                    Selected node: <strong><span id="selectedNodeId">None</span></strong>
                </div>

                <label for="editNodeLabel">Label</label>
                <input type="text" id="editNodeLabel" placeholder="Edit label of selected node...">

                <label for="editNodeType">Type</label>
                <select id="editNodeType">
                    <option value="">-- select type --</option>
                </select>

                <div class="button-row">
                    <button id="btnUpdateNode">Update Selected Node</button>
                    <button id="btnDeleteNode" class="danger">Delete Selected Node</button>
                </div>

                <div id="nodeAttrEditor" style="margin-top:8px; padding-top:8px; border-top:1px solid #ddd;">
                    <label>Node Attributes</label>
                    <div id="nodeAttrValues">
                        <!-- Dynamic attribute value editors will be rendered here -->
                        <div class="small">No attributes defined. Add attributes in "Manage Attributes".</div>
                    </div>
                </div>

                <div class="small" style="margin-top:4px;">
                    Click a node in the graph to select it for editing.
                </div>
            </div>

            <!-- Edge editor -->
            <div class="section">
                <h3>Edge Editor</h3>
                <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
                    <label for="edgeFromInput" style="margin-bottom:0;">Node A</label>
                    <button id="btnFocusNodeA" class="small-btn">Focus</button>
                </div>
                <div style="position:relative;">
                    <input type="text" id="edgeFromInput" placeholder="Type to search..." autocomplete="off">
                    <input type="hidden" id="edgeFrom">
                    <div id="edgeFromResults" class="search-results"></div>
                </div>

                <label for="edgeToInput">Node B</label>
                <div style="position:relative;">
                    <input type="text" id="edgeToInput" placeholder="Type to search..." autocomplete="off">
                    <input type="hidden" id="edgeTo">
                    <div id="edgeToResults" class="search-results"></div>
                </div>

                <div class="button-row">
                    <button id="btnAddEdge" class="primary">Add Edge</button>
                    <button id="btnUpdateEdge">Update Edge</button>
                    <button id="btnDeleteEdge" class="danger">Delete Edge</button>
                </div>

                <div id="edgeAttrEditor" style="margin-top:8px; padding-top:8px; border-top:1px solid #ddd;">
                    <label>Edge Attributes</label>
                    <div id="edgeAttrValues">
                        <!-- Dynamic attribute value editors will be rendered here -->
                        <div class="small">No attributes defined. Add attributes in "Manage Attributes".</div>
                    </div>
                </div>

                <div class="small" style="margin-top:4px;">
                    Hold <strong>Shift</strong> and click two nodes to create an edge.<br>
                    Hold <strong>Delete</strong> and click an edge to delete it.<br>
                    Click an edge to select and edit its attributes.
                </div>
            </div>

            <!-- View / Behavior -->
            <div class="section">
                <h3>View & Behavior</h3>

                <div id="viewStateIndicator" class="view-state-indicator">
                    Showing: <strong><span id="viewStateText">All nodes</span></strong>
                </div>

                <div id="isolateSelectedSummary" class="small" style="margin-bottom:4px;">
                    Selected for isolate: <strong><span id="isolateNodeDisplay">None</span></strong>
                </div>

                <div class="button-row">
                    <button id="btnIsolate">Isolate Connected</button>
                    <button id="btnShowAll">Show All</button>
                </div>

                <div id="filterContainer" class="filters">
                    <!-- Dynamic type filters will be rendered here -->
                    <label class="type-label">
                        <input type="checkbox" id="onlyOrphans">
                        Only Orphans (<span id="countOrphans">0</span>)
                    </label>
                </div>

                <label for="sortMethod" class="small">Layout method:</label>
                <select id="sortMethod">
                    <option value="directed">Hierarchical (by type order)</option>
                    <option value="alpha">Network (force-directed)</option>
                </select>

                <div class="small" style="margin-top:4px;">
                    Orphans are nodes with no edges. They blink between their type color and white.
                </div>
            </div>
        </div>

        <div id="main">
            <div id="network"></div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal-overlay">
        <div class="modal-content">
            <button id="btnCloseHelp" class="modal-close">&times;</button>
            <h3>How to Use</h3>
            <p style="font-size:12px;">This tool lets you create and edit graph models with typed nodes and edges.</p>

            <h3>Import / Export</h3>
            <ul>
                <li><strong>nodes.csv</strong>: Columns - Node, Type, then attribute columns</li>
                <li><strong>edges.csv</strong>: Columns - Node 1, Node 2, then attribute columns</li>
                <li>Each attribute is its own column (header = attribute name)</li>
                <li>Upload files and click "Import CSV Files"</li>
                <li>Types and attributes are auto-detected from headers</li>
                <li>Hover over nodes/edges to see their attributes</li>
            </ul>

            <h3>Manage Attributes</h3>
            <ul>
                <li>Switch between Node and Edge attributes with the dropdown</li>
                <li>Add new attributes - creates new columns in CSV export</li>
                <li>Delete attributes - removes from all nodes/edges</li>
                <li>Edit attribute values in the Edit Node or Edge Editor sections</li>
            </ul>

            <h3>Style Rules</h3>
            <ul>
                <li><strong>Node Shape Rules:</strong> Change node shapes based on attribute values</li>
                <li><strong>Edge Color Rules:</strong> Change edge colors based on attribute values</li>
                <li>Rules are applied in order - first match wins</li>
                <li>Add rules: select attribute, enter value to match, choose shape/color</li>
                <li>Click 'x' to delete a rule</li>
            </ul>

            <h3>Find Node</h3>
            <ul>
                <li>Type in the search box to find nodes by name</li>
                <li>Use <kbd>↑</kbd> <kbd>↓</kbd> arrows to navigate results</li>
                <li>Press <kbd>Enter</kbd> to select and zoom to node</li>
                <li>Press <kbd>Esc</kbd> to close results</li>
            </ul>

            <h3>Mouse Controls</h3>
            <ul>
                <li><strong>Drag node</strong>: Reposition</li>
                <li><strong>Scroll</strong>: Zoom in/out</li>
                <li><strong>Drag background</strong>: Pan view</li>
            </ul>

            <h3>Keyboard + Mouse (Nodes)</h3>
            <ul>
                <li><strong>Click node</strong>: Select and focus on the node</li>
                <li><strong>Click type chip</strong>: Focus on first node of that type</li>
                <li><strong>Double-click node</strong>: Isolate its connected component</li>
                <li><strong>Double-click isolated node</strong>: Show all nodes</li>
            </ul>

            <h3>Keyboard + Mouse (Edges)</h3>
            <ul>
                <li><kbd>Shift</kbd> + <strong>click node</strong>: Start edge creation (node highlights)</li>
                <li><kbd>Shift</kbd> + <strong>click second node</strong>: Complete edge (focuses on target)</li>
                <li><kbd>Shift</kbd> + <strong>click same node</strong>: Cancel edge creation</li>
                <li><kbd>Delete</kbd> or <kbd>Backspace</kbd> + <strong>click edge</strong>: Delete edge</li>
            </ul>

            <h3>Managing Types</h3>
            <ul>
                <li>Types are created automatically on import</li>
                <li>Add new types manually in "Manage Types" section</li>
                <li>Delete types only if no nodes use them</li>
                <li>Filter view by type using checkboxes</li>
            </ul>

            <h3>View Options</h3>
            <ul>
                <li><strong>Isolate Connected</strong>: Show only the selected node's connected component</li>
                <li><strong>Show All</strong>: Reset to full graph view</li>
                <li><strong>Only Orphans</strong>: Show nodes with no edges</li>
                <li><strong>Layout</strong>: Switch between hierarchical and force-directed</li>
            </ul>
        </div>
    </div>
</div>

<script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
<script>
    // Color palette for auto-assigning colors to types
    const COLOR_PALETTE = [
        '#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#f39c12', '#1abc9c',
        '#e91e63', '#00bcd4', '#8bc34a', '#ff5722', '#607d8b', '#795548',
        '#673ab7', '#009688', '#ffc107', '#03a9f4', '#cddc39', '#ff9800'
    ];

    // Dynamic type storage: Map of typeName -> { color: string }
    let nodeTypes = new Map();
    let colorIndex = 0;

    // Attribute schemas: arrays of attribute names
    let nodeAttributes = [];  // e.g., ['priority', 'owner', 'status']
    let edgeAttributes = [];  // e.g., ['weight', 'confidence']

    // Style rules: maps attribute+value to visual property
    // Format: { attribute: string, value: string, style: string (color/shape) }
    let nodeShapeRules = [];  // e.g., [{ attribute: 'status', value: 'active', shape: 'star' }]
    let edgeColorRules = [];  // e.g., [{ attribute: 'weight', value: 'high', color: '#ff0000' }]

    // Available shapes for nodes (vis.js supported shapes)
    const availableShapes = ['dot', 'diamond', 'star', 'triangle', 'triangleDown', 'hexagon', 'square', 'box', 'ellipse', 'circle', 'database'];

    let nodesData = new vis.DataSet([]);
    let edgesData = new vis.DataSet([]);

    let networkNodes = null;
    let networkEdges = null;
    let network = null;

    let selectedNodeId = null;
    let selectedEdgeId = null;
    let isolatedNodeId = null;
    let edgeCreationSourceId = null;
    let deletePressed = false;

    let isIsolated = false;
    let isolateSet = null;

    let currentSortMethod = 'alpha';

    let viewFilters = {
        onlyOrphans: false
    };

    let blinkInterval = null;
    let blinkingIds = new Set();

    let isDirty = false;

    // Pending CSV files for import
    let pendingNodesCSV = null;
    let pendingEdgesCSV = null;

    // --- Type Management ---

    function getNextColor() {
        const color = COLOR_PALETTE[colorIndex % COLOR_PALETTE.length];
        colorIndex++;
        return color;
    }

    function addType(name, color) {
        if (!name || nodeTypes.has(name)) return false;
        nodeTypes.set(name, { color: color || getNextColor() });
        viewFilters[name] = true;
        updateTypeUI();
        return true;
    }

    function removeType(name) {
        if (!nodeTypes.has(name)) return;
        const nodesWithType = nodesData.get({ filter: function(n) { return n.type === name; } });
        if (nodesWithType.length > 0) {
            alert('Cannot delete type "' + name + '": ' + nodesWithType.length + ' node(s) are using it.');
            return;
        }
        nodeTypes.delete(name);
        delete viewFilters[name];
        updateTypeUI();
    }

    function getTypeColor(typeName) {
        if (nodeTypes.has(typeName)) {
            return nodeTypes.get(typeName).color;
        }
        return '#999999';
    }

    function updateTypeUI() {
        // Update legend with color-coded chips
        const legendEl = document.querySelector('#causal-editor #typeLegend');
        legendEl.innerHTML = '';
        nodeTypes.forEach(function(info, name) {
            const span = document.createElement('span');
            span.className = 'tag';
            span.style.backgroundColor = info.color;
            span.style.color = '#ffffff';
            span.textContent = name;
            span.title = 'Click to find first "' + name + '" node';
            span.addEventListener('click', function() {
                // Find first node of this type and focus on it
                const nodes = nodesData.get({ filter: function(n) { return n.type === name; } });
                if (nodes.length > 0) {
                    const nodeId = nodes[0].id;
                    selectNodeInUI(nodeId);
                    focusOnNode(nodeId);
                }
            });
            legendEl.appendChild(span);
        });

        // Update type list with delete buttons
        const typeListEl = document.querySelector('#causal-editor #typeList');
        typeListEl.innerHTML = '';
        nodeTypes.forEach(function(info, name) {
            const div = document.createElement('div');
            div.className = 'type-item';

            const dot = document.createElement('span');
            dot.className = 'type-color-dot';
            dot.style.backgroundColor = info.color;

            const label = document.createElement('span');
            label.textContent = name;

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'type-delete-btn danger';
            deleteBtn.textContent = 'x';
            deleteBtn.onclick = function() { removeType(name); };

            div.appendChild(dot);
            div.appendChild(label);
            div.appendChild(deleteBtn);
            typeListEl.appendChild(div);
        });

        // Update type dropdowns
        const typeOptions = '<option value="">-- select type --</option>' +
            Array.from(nodeTypes.keys()).map(function(name) {
                return '<option value="' + name + '">' + name + '</option>';
            }).join('');
        createNodeTypeEl.innerHTML = typeOptions;
        editNodeTypeEl.innerHTML = typeOptions;

        // Update filter checkboxes
        updateFilterCheckboxes();
    }

    function updateFilterCheckboxes() {
        const filterContainer = document.querySelector('#causal-editor #filterContainer');
        // Keep only the orphans checkbox, rebuild type filters
        const orphansLabel = filterContainer.querySelector('.type-label:last-child');

        filterContainer.innerHTML = '';
        nodeTypes.forEach(function(info, name) {
            const label = document.createElement('label');
            label.className = 'type-label';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = viewFilters[name] !== false;
            checkbox.addEventListener('change', function() {
                viewFilters[name] = checkbox.checked;
                applyVisibility();
            });

            const countSpan = document.createElement('span');
            countSpan.id = 'count_' + name.replace(/\s+/g, '_');
            countSpan.textContent = '0';

            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(' ' + name + ' ('));
            label.appendChild(countSpan);
            label.appendChild(document.createTextNode(')'));

            filterContainer.appendChild(label);
        });

        // Re-add orphans checkbox
        const orphansLabelNew = document.createElement('label');
        orphansLabelNew.className = 'type-label';
        const orphansCheckbox = document.createElement('input');
        orphansCheckbox.type = 'checkbox';
        orphansCheckbox.id = 'onlyOrphans';
        orphansCheckbox.checked = viewFilters.onlyOrphans;
        orphansCheckbox.addEventListener('change', function() {
            viewFilters.onlyOrphans = orphansCheckbox.checked;
            applyVisibility();
        });
        orphansLabelNew.appendChild(orphansCheckbox);
        orphansLabelNew.appendChild(document.createTextNode(' Only Orphans ('));
        const orphansCount = document.createElement('span');
        orphansCount.id = 'countOrphans';
        orphansCount.textContent = '0';
        orphansLabelNew.appendChild(orphansCount);
        orphansLabelNew.appendChild(document.createTextNode(')'));
        filterContainer.appendChild(orphansLabelNew);
    }

    // --- Attribute Management ---

    function addAttribute(targetType, attrName) {
        if (!attrName || !attrName.trim()) return false;
        attrName = attrName.trim();

        if (targetType === 'node') {
            if (nodeAttributes.includes(attrName)) return false;
            nodeAttributes.push(attrName);
        } else {
            if (edgeAttributes.includes(attrName)) return false;
            edgeAttributes.push(attrName);
        }
        updateAttributeListUI();
        updateNodeAttrValuesUI();
        updateEdgeAttrValuesUI();
        updateStyleRuleAttributeDropdowns();
        return true;
    }

    function removeAttribute(targetType, attrName) {
        if (targetType === 'node') {
            const idx = nodeAttributes.indexOf(attrName);
            if (idx === -1) return;
            // Remove attribute values from all nodes
            nodesData.get().forEach(function(n) {
                if (n.attributes && n.attributes[attrName] !== undefined) {
                    const attrs = Object.assign({}, n.attributes);
                    delete attrs[attrName];
                    nodesData.update({ id: n.id, attributes: attrs });
                }
            });
            nodeAttributes.splice(idx, 1);
            // Remove any shape rules using this attribute
            nodeShapeRules = nodeShapeRules.filter(function(rule) {
                return rule.attribute !== attrName;
            });
            updateNodeShapeRulesUI();
        } else {
            const idx = edgeAttributes.indexOf(attrName);
            if (idx === -1) return;
            // Remove attribute values from all edges
            edgesData.get().forEach(function(e) {
                if (e.attributes && e.attributes[attrName] !== undefined) {
                    const attrs = Object.assign({}, e.attributes);
                    delete attrs[attrName];
                    edgesData.update({ id: e.id, attributes: attrs });
                }
            });
            edgeAttributes.splice(idx, 1);
            // Remove any color rules using this attribute
            edgeColorRules = edgeColorRules.filter(function(rule) {
                return rule.attribute !== attrName;
            });
            updateEdgeColorRulesUI();
        }
        isDirty = true;
        updateAttributeListUI();
        updateNodeAttrValuesUI();
        updateEdgeAttrValuesUI();
        updateStyleRuleAttributeDropdowns();
        applyVisibility();
    }

    function updateAttributeListUI() {
        const attrListEl = document.querySelector('#causal-editor #attrList');
        const targetType = document.querySelector('#causal-editor #attrTargetType').value;
        const attrs = targetType === 'node' ? nodeAttributes : edgeAttributes;

        attrListEl.innerHTML = '';

        if (attrs.length === 0) {
            attrListEl.innerHTML = '<div class="small">No attributes defined for ' + targetType + 's.</div>';
            return;
        }

        attrs.forEach(function(attrName) {
            const div = document.createElement('div');
            div.className = 'attr-item';

            const nameSpan = document.createElement('span');
            nameSpan.textContent = attrName;

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'type-delete-btn danger';
            deleteBtn.textContent = 'x';
            deleteBtn.onclick = function() {
                if (confirm('Delete attribute "' + attrName + '" and all its values?')) {
                    removeAttribute(targetType, attrName);
                }
            };

            div.appendChild(nameSpan);
            div.appendChild(deleteBtn);
            attrListEl.appendChild(div);
        });
    }

    function updateNodeAttrValuesUI() {
        const containerEl = document.querySelector('#causal-editor #nodeAttrValues');
        containerEl.innerHTML = '';

        if (nodeAttributes.length === 0) {
            containerEl.innerHTML = '<div class="small">No attributes defined. Add attributes in "Manage Attributes".</div>';
            return;
        }

        if (!selectedNodeId) {
            containerEl.innerHTML = '<div class="small">Select a node to edit its attributes.</div>';
            return;
        }

        const node = nodesData.get(selectedNodeId);
        if (!node) {
            containerEl.innerHTML = '<div class="small">Select a node to edit its attributes.</div>';
            return;
        }

        const attrs = node.attributes || {};

        nodeAttributes.forEach(function(attrName) {
            const row = document.createElement('div');
            row.className = 'attr-value-row';

            const label = document.createElement('label');
            label.textContent = attrName + ':';

            const input = document.createElement('input');
            input.type = 'text';
            input.value = attrs[attrName] || '';
            input.dataset.attrName = attrName;
            input.placeholder = 'Enter value...';

            row.appendChild(label);
            row.appendChild(input);
            containerEl.appendChild(row);
        });
    }

    function updateEdgeAttrValuesUI() {
        const containerEl = document.querySelector('#causal-editor #edgeAttrValues');
        containerEl.innerHTML = '';

        if (edgeAttributes.length === 0) {
            containerEl.innerHTML = '<div class="small">No attributes defined. Add attributes in "Manage Attributes".</div>';
            return;
        }

        const fromId = document.querySelector('#causal-editor #edgeFrom').value;
        const toId = document.querySelector('#causal-editor #edgeTo').value;

        if (!fromId || !toId) {
            containerEl.innerHTML = '<div class="small">Select an edge to edit its attributes.</div>';
            return;
        }

        // Find the edge
        const edges = edgesData.get({
            filter: function(e) {
                return (e.from === fromId && e.to === toId) ||
                       (e.from === toId && e.to === fromId);
            }
        });

        if (edges.length === 0) {
            containerEl.innerHTML = '<div class="small">No edge exists between selected nodes.</div>';
            return;
        }

        const edge = edges[0];
        selectedEdgeId = edge.id;
        const attrs = edge.attributes || {};

        edgeAttributes.forEach(function(attrName) {
            const row = document.createElement('div');
            row.className = 'attr-value-row';

            const label = document.createElement('label');
            label.textContent = attrName + ':';

            const input = document.createElement('input');
            input.type = 'text';
            input.value = attrs[attrName] || '';
            input.dataset.attrName = attrName;
            input.placeholder = 'Enter value...';

            row.appendChild(label);
            row.appendChild(input);
            containerEl.appendChild(row);
        });
    }

    function getNodeAttrValuesFromUI() {
        const containerEl = document.querySelector('#causal-editor #nodeAttrValues');
        const inputs = containerEl.querySelectorAll('input[data-attr-name]');
        const attrs = {};
        inputs.forEach(function(input) {
            const val = input.value.trim();
            if (val) {
                attrs[input.dataset.attrName] = val;
            }
        });
        return attrs;
    }

    function getEdgeAttrValuesFromUI() {
        const containerEl = document.querySelector('#causal-editor #edgeAttrValues');
        const inputs = containerEl.querySelectorAll('input[data-attr-name]');
        const attrs = {};
        inputs.forEach(function(input) {
            const val = input.value.trim();
            if (val) {
                attrs[input.dataset.attrName] = val;
            }
        });
        return attrs;
    }

    // Format attributes object for tooltip display
    function formatAttributesTooltip(attrs) {
        if (!attrs || typeof attrs !== 'object') return null;
        const keys = Object.keys(attrs);
        if (keys.length === 0) return null;
        return keys.map(function(key) {
            return key + ': ' + attrs[key];
        }).join('\n');
    }

    // --- Style Rules Management ---

    function updateStyleRuleAttributeDropdowns() {
        // Update node shape attribute dropdown
        const nodeShapeAttrEl = document.querySelector('#causal-editor #nodeShapeAttr');
        nodeShapeAttrEl.innerHTML = '<option value="">-- attribute --</option>';
        nodeAttributes.forEach(function(attr) {
            const opt = document.createElement('option');
            opt.value = attr;
            opt.textContent = attr;
            nodeShapeAttrEl.appendChild(opt);
        });

        // Update edge color attribute dropdown
        const edgeColorAttrEl = document.querySelector('#causal-editor #edgeColorAttr');
        edgeColorAttrEl.innerHTML = '<option value="">-- attribute --</option>';
        edgeAttributes.forEach(function(attr) {
            const opt = document.createElement('option');
            opt.value = attr;
            opt.textContent = attr;
            edgeColorAttrEl.appendChild(opt);
        });
    }

    function updateNodeShapeRulesUI() {
        const listEl = document.querySelector('#causal-editor #nodeShapeRulesList');
        listEl.innerHTML = '';

        if (nodeShapeRules.length === 0) {
            listEl.innerHTML = '<div class="small">No shape rules defined.</div>';
            return;
        }

        nodeShapeRules.forEach(function(rule, idx) {
            const div = document.createElement('div');
            div.className = 'rule-item';

            const textSpan = document.createElement('span');
            textSpan.textContent = rule.attribute + ' = "' + rule.value + '" → ' + rule.shape;

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'type-delete-btn danger';
            deleteBtn.textContent = 'x';
            deleteBtn.onclick = function() {
                nodeShapeRules.splice(idx, 1);
                updateNodeShapeRulesUI();
                isDirty = true;
                applyVisibility();
            };

            div.appendChild(textSpan);
            div.appendChild(deleteBtn);
            listEl.appendChild(div);
        });
    }

    function updateEdgeColorRulesUI() {
        const listEl = document.querySelector('#causal-editor #edgeColorRulesList');
        listEl.innerHTML = '';

        if (edgeColorRules.length === 0) {
            listEl.innerHTML = '<div class="small">No color rules defined.</div>';
            return;
        }

        edgeColorRules.forEach(function(rule, idx) {
            const div = document.createElement('div');
            div.className = 'rule-item';

            const textSpan = document.createElement('span');
            const swatch = document.createElement('span');
            swatch.className = 'color-swatch';
            swatch.style.backgroundColor = rule.color;
            textSpan.textContent = rule.attribute + ' = "' + rule.value + '" → ';
            textSpan.appendChild(swatch);

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'type-delete-btn danger';
            deleteBtn.textContent = 'x';
            deleteBtn.onclick = function() {
                edgeColorRules.splice(idx, 1);
                updateEdgeColorRulesUI();
                isDirty = true;
                applyVisibility();
            };

            div.appendChild(textSpan);
            div.appendChild(deleteBtn);
            listEl.appendChild(div);
        });
    }

    function getNodeShapeFromRules(node) {
        if (!node.attributes || typeof node.attributes !== 'object') {
            return 'dot';
        }
        for (let i = 0; i < nodeShapeRules.length; i++) {
            const rule = nodeShapeRules[i];
            const attrValue = node.attributes[rule.attribute];
            if (attrValue !== undefined && String(attrValue).trim() === String(rule.value).trim()) {
                return rule.shape;
            }
        }
        return 'dot';
    }

    function getEdgeColorFromRules(edge) {
        if (!edge.attributes || typeof edge.attributes !== 'object') return '#666666';
        for (let i = 0; i < edgeColorRules.length; i++) {
            const rule = edgeColorRules[i];
            const attrValue = edge.attributes[rule.attribute];
            if (attrValue !== undefined && String(attrValue).trim() === String(rule.value).trim()) {
                return rule.color;
            }
        }
        return '#666666';
    }

    // --- Helpers ---

    function wrapLabel(text, maxLen) {
        if (maxLen === undefined) maxLen = 22;
        if (!text) return '';
        const words = String(text).split(/\s+/);
        const lines = [];
        let line = '';
        words.forEach(function(word) {
            const candidate = (line ? line + ' ' : '') + word;
            if (candidate.length > maxLen) {
                if (line) lines.push(line);
                line = word;
            } else {
                line = candidate;
            }
        });
        if (line) lines.push(line);
        return lines.join('\n');
    }

    function slugifyLabel(label) {
        let slug = label.trim().replace(/[\s]+/g, '_');
        slug = slug.replace(/[^A-Za-z0-9_]/g, '_');
        if (!slug) slug = 'node';
        const base = slug;
        let counter = 1;
        while (nodesData.get(slug)) {
            slug = base + '_' + counter;
            counter++;
        }
        return slug;
    }

    // Focus the network view on a specific node
    function focusOnNode(nodeId, options) {
        if (!network || !networkNodes) return;
        const node = networkNodes.get(nodeId);
        if (!node) return;

        const opts = options || {};
        const scale = opts.scale || 1.2;
        const animate = opts.animate !== false;

        network.selectNodes([nodeId]);
        network.focus(nodeId, {
            scale: scale,
            animation: animate ? {
                duration: 400,
                easingFunction: 'easeInOutQuad'
            } : false
        });
    }

    // --- Drawing & visibility ---

    function drawNetwork(viewNodesArr, viewEdgesArr) {
        const container = document.querySelector('#causal-editor #network');

        const useHierarchical = (currentSortMethod === 'directed');

        networkNodes = new vis.DataSet(viewNodesArr);
        networkEdges = new vis.DataSet(viewEdgesArr);

        const data = { nodes: networkNodes, edges: networkEdges };

        const options = {
            layout: useHierarchical ? {
                hierarchical: {
                    enabled: true,
                    direction: 'UD',
                    sortMethod: 'directed',
                    levelSeparation: 150,
                    nodeSpacing: 120,
                    treeSpacing: 200,
                    blockShifting: true,
                    edgeMinimization: true,
                    parentCentralization: true,
                    shakeTowards: 'roots'
                }
            } : {},
            physics: useHierarchical ? { enabled: false } : {
                enabled: true,
                solver: 'forceAtlas2Based',
                forceAtlas2Based: {
                    gravitationalConstant: -50,
                    centralGravity: 0.01,
                    springLength: 100,
                    springConstant: 0.08
                },
                stabilization: { iterations: 150 }
            },
            nodes: {
                size: 20,
                font: { size: 12, align: 'center', multi: 'md' },
                scaling: { label: { enabled: true, min: 10, max: 16 } },
                widthConstraint: { maximum: 200 }
            },
            edges: { arrows: { to: { enabled: true, scaleFactor: 0.5 } } },
            interaction: { dragNodes: true, dragView: true, zoomView: true, hover: true }
        };

        if (network) network.destroy();
        network = new vis.Network(container, data, options);

        network.on('click', function(params) {
            const srcEvent = params.event && params.event.srcEvent;
            const shift = srcEvent && srcEvent.shiftKey;

            if (params.edges && params.edges.length && (!params.nodes || !params.nodes.length)) {
                const edgeId = params.edges[0];
                const e = networkEdges.get(edgeId);
                if (e) {
                    // Update hidden inputs
                    edgeFromEl.value = String(e.from);
                    edgeToEl.value = String(e.to);
                    // Update visible inputs with node labels
                    const fromNode = nodesData.get(e.from);
                    const toNode = nodesData.get(e.to);
                    edgeFromInputEl.value = fromNode ? (fromNode.rawLabel || fromNode.label) : e.from;
                    edgeToInputEl.value = toNode ? (toNode.rawLabel || toNode.label) : e.to;
                    // Update edge attribute values UI
                    updateEdgeAttrValuesUI();
                }

                if (deletePressed) {
                    handleEdgeDeleteClick(params.edges);
                    return;
                }
            }

            if (shift && params.nodes && params.nodes.length) {
                handleShiftNodeClick(params.nodes[0]);
                return;
            }

            if (params.nodes && params.nodes.length) {
                const nodeId = params.nodes[0];
                selectNodeInUI(nodeId);
                // Focus on the clicked node
                focusOnNode(nodeId);
            } else {
                clearSelectedNodeInUI();
            }
        });

        network.on('doubleClick', function(params) {
            if (!params.nodes || !params.nodes.length) return;
            const nodeId = params.nodes[0];

            if (isIsolated && isolatedNodeId === nodeId) {
                showAll();
            } else {
                selectNodeInUI(nodeId);
                isolateSelectedNode();
            }
        });

        network.fit({ animation: false });
    }

    function updateBlinking(degreeMap, visibleNodeIds) {
        if (blinkInterval) {
            clearInterval(blinkInterval);
            blinkInterval = null;
        }
        blinkingIds = new Set();
        if (!networkNodes) return;

        Object.keys(degreeMap).forEach(function(id) {
            if (degreeMap[id] === 0 && visibleNodeIds.has(id)) {
                blinkingIds.add(id);
            }
        });

        if (!blinkingIds.size) return;

        let blinkOn = false;
        blinkInterval = setInterval(function() {
            const updates = [];
            blinkingIds.forEach(function(id) {
                const n = networkNodes.get(id);
                if (!n) return;
                const base = n.baseColor || n.color || 'gray';
                updates.push({ id: id, color: blinkOn ? '#ffffff' : base });
            });
            if (updates.length) networkNodes.update(updates);
            blinkOn = !blinkOn;
        }, 800);
    }

    function updateCounts(degreeMap) {
        const counts = {};
        nodeTypes.forEach(function(info, name) { counts[name] = 0; });

        nodesData.get().forEach(function(n) {
            if (counts[n.type] != null) counts[n.type]++;
        });

        nodeTypes.forEach(function(info, name) {
            const countEl = document.querySelector('#causal-editor #count_' + name.replace(/\s+/g, '_'));
            if (countEl) countEl.textContent = counts[name] || 0;
        });

        let orphanCount = 0;
        Object.keys(degreeMap).forEach(function(id) {
            if (degreeMap[id] === 0) orphanCount++;
        });
        const orphansEl = document.querySelector('#causal-editor #countOrphans');
        if (orphansEl) orphansEl.textContent = orphanCount;
    }

    function applyVisibility() {
        const degreeMap = {};
        nodesData.get().forEach(function(n) { degreeMap[n.id] = 0; });
        edgesData.get().forEach(function(e) {
            if (degreeMap[e.from] != null) degreeMap[e.from]++;
            if (degreeMap[e.to] != null) degreeMap[e.to]++;
        });

        const visibleNodeIds = new Set();

        nodesData.get().forEach(function(n) {
            const id = n.id;
            let visible = true;

            if (isIsolated && isolateSet && !isolateSet.has(id)) visible = false;

            if (visible && viewFilters[n.type] === false) visible = false;
            if (visible && viewFilters.onlyOrphans && degreeMap[id] > 0) visible = false;

            if (visible) visibleNodeIds.add(id);
        });

        // Build type-to-level mapping based on type order in the Map
        const typeToLevel = new Map();
        let levelIndex = 0;
        nodeTypes.forEach(function(info, typeName) {
            typeToLevel.set(typeName, levelIndex);
            levelIndex++;
        });

        const viewNodesArr = [];
        nodesData.get().forEach(function(n) {
            if (!visibleNodeIds.has(n.id)) return;
            // Ensure attributes is always an object
            if (!n.attributes || typeof n.attributes !== 'object') {
                n.attributes = {};
            }
            const baseColor = n.baseColor || getTypeColor(n.type);
            // Assign level based on type order for hierarchical layout
            const level = typeToLevel.has(n.type) ? typeToLevel.get(n.type) : levelIndex;
            // Build tooltip with node info and attributes
            let tooltip = (n.rawLabel || n.label) + '\nType: ' + (n.type || 'Unknown');
            const attrTooltip = formatAttributesTooltip(n.attributes);
            if (attrTooltip) {
                tooltip += '\n\n' + attrTooltip;
            }
            // Get shape from style rules
            const shape = getNodeShapeFromRules(n);
            viewNodesArr.push({
                id: n.id,
                label: n.label,
                rawLabel: n.rawLabel,
                type: n.type,
                attributes: n.attributes,
                baseColor: baseColor,
                color: baseColor,
                level: level,
                shape: shape,
                title: tooltip
            });
        });

        const viewEdgesArr = [];
        edgesData.get().forEach(function(e) {
            if (visibleNodeIds.has(e.from) && visibleNodeIds.has(e.to)) {
                // Ensure attributes is always an object
                if (!e.attributes || typeof e.attributes !== 'object') {
                    e.attributes = {};
                }
                // Build edge tooltip
                const fromNode = nodesData.get(e.from);
                const toNode = nodesData.get(e.to);
                const fromLabel = fromNode ? (fromNode.rawLabel || fromNode.label) : e.from;
                const toLabel = toNode ? (toNode.rawLabel || toNode.label) : e.to;
                let edgeTooltip = fromLabel + ' → ' + toLabel;
                const edgeAttrTooltip = formatAttributesTooltip(e.attributes);
                if (edgeAttrTooltip) {
                    edgeTooltip += '\n\n' + edgeAttrTooltip;
                }
                // Get color from style rules (falls back to default)
                const edgeColor = getEdgeColorFromRules(e);
                viewEdgesArr.push({
                    id: e.id,
                    from: e.from,
                    to: e.to,
                    attributes: e.attributes,
                    color: { color: edgeColor, highlight: edgeColor, hover: edgeColor },
                    title: edgeTooltip
                });
            }
        });

        updateCounts(degreeMap);
        drawNetwork(viewNodesArr, viewEdgesArr);
        updateBlinking(degreeMap, visibleNodeIds);
    }

    // --- Isolate ---

    function isolateSelectedNode() {
        if (!selectedNodeId) {
            alert('Select a node in the graph first.');
            return;
        }
        const startNode = nodesData.get(selectedNodeId);
        if (!startNode) {
            alert('Selected node not found.');
            return;
        }

        // BFS to find all connected nodes (undirected)
        const adj = {};
        nodesData.get().forEach(function(n) { adj[n.id] = new Set(); });
        edgesData.get().forEach(function(e) {
            if (adj[e.from]) adj[e.from].add(e.to);
            if (adj[e.to]) adj[e.to].add(e.from);
        });

        const visited = new Set([selectedNodeId]);
        const queue = [selectedNodeId];
        while (queue.length) {
            const id = queue.shift();
            (adj[id] || []).forEach(function(neighborId) {
                if (!visited.has(neighborId)) {
                    visited.add(neighborId);
                    queue.push(neighborId);
                }
            });
        }

        isIsolated = true;
        isolateSet = visited;
        isolatedNodeId = selectedNodeId;

        applyVisibility();
        updateViewStateIndicator();

        // Refocus on the isolated node after the graph redraws
        setTimeout(function() {
            focusOnNode(isolatedNodeId);
        }, 150);
    }

    function showAll() {
        isIsolated = false;
        isolateSet = null;
        isolatedNodeId = null;
        applyVisibility();
        updateViewStateIndicator();

        // Zoom out to fit all nodes after showing all
        setTimeout(function() {
            if (network) {
                network.fit({
                    animation: {
                        duration: 400,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }
        }, 150);
    }

    // --- Edge helpers ---

    function handleShiftNodeClick(nodeId) {
        if (!edgeCreationSourceId) {
            edgeCreationSourceId = nodeId;
            if (network) network.selectNodes([nodeId]);
            return;
        }

        if (edgeCreationSourceId === nodeId) {
            edgeCreationSourceId = null;
            if (network) network.selectNodes([]);
            return;
        }

        const fromId = edgeCreationSourceId;
        const toId = nodeId;
        edgeCreationSourceId = null;
        if (network) network.selectNodes([]);

        // Check if edge already exists (either direction)
        const existing = edgesData.get({
            filter: function(e) {
                return (e.from === fromId && e.to === toId) ||
                       (e.from === toId && e.to === fromId);
            }
        });
        if (existing.length) {
            alert('An edge between these nodes already exists.');
            return;
        }

        edgesData.add({ from: fromId, to: toId, color: '#666666' });
        isDirty = true;
        refreshNodeSelects();
        applyVisibility();
        // Focus on the target node after creating the edge
        setTimeout(function() {
            selectNodeInUI(toId);
            focusOnNode(toId);
        }, 100);
    }

    function handleEdgeDeleteClick(edgeIds) {
        if (!edgeIds || !edgeIds.length) return;
        if (!confirm('Delete selected edge(s)?')) return;
        edgesData.remove(edgeIds);
        isDirty = true;
        refreshNodeSelects();
        deletePressed = false;
        applyVisibility();
    }

    // --- DOM wiring ---

    const importNodesFileEl = document.querySelector('#causal-editor #importNodesFile');
    const importEdgesFileEl = document.querySelector('#causal-editor #importEdgesFile');

    const selectedNodeIdEl = document.querySelector('#causal-editor #selectedNodeId');
    const createNodeLabelEl = document.querySelector('#causal-editor #createNodeLabel');
    const createNodeTypeEl = document.querySelector('#causal-editor #createNodeType');

    const editNodeLabelEl = document.querySelector('#causal-editor #editNodeLabel');
    const editNodeTypeEl = document.querySelector('#causal-editor #editNodeType');

    const edgeFromEl = document.querySelector('#causal-editor #edgeFrom');
    const edgeToEl = document.querySelector('#causal-editor #edgeTo');
    const edgeFromInputEl = document.querySelector('#causal-editor #edgeFromInput');
    const edgeToInputEl = document.querySelector('#causal-editor #edgeToInput');
    const edgeFromResultsEl = document.querySelector('#causal-editor #edgeFromResults');
    const edgeToResultsEl = document.querySelector('#causal-editor #edgeToResults');

    const sortMethodEl = document.querySelector('#causal-editor #sortMethod');
    const isolateNodeDisplayEl = document.querySelector('#causal-editor #isolateNodeDisplay');

    const newTypeNameEl = document.querySelector('#causal-editor #newTypeName');

    // CSV file handlers
    importNodesFileEl.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(ev) {
            pendingNodesCSV = ev.target.result || '';
        };
        reader.readAsText(file);
    });

    importEdgesFileEl.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(ev) {
            pendingEdgesCSV = ev.target.result || '';
        };
        reader.readAsText(file);
    });

    document.querySelector('#causal-editor #btnImportCSV').addEventListener('click', function() {
        if (!pendingNodesCSV && !pendingEdgesCSV) {
            alert('Please select at least one CSV file to import.');
            return;
        }
        handleCSVImport(pendingNodesCSV, pendingEdgesCSV);
        pendingNodesCSV = null;
        pendingEdgesCSV = null;
        importNodesFileEl.value = '';
        importEdgesFileEl.value = '';
    });

    document.querySelector('#causal-editor #btnClear').addEventListener('click', function() {
        if (!confirm('Clear all nodes, edges, types, attributes, and style rules?')) return;
        nodesData.clear();
        edgesData.clear();
        nodeTypes.clear();
        nodeAttributes = [];
        edgeAttributes = [];
        nodeShapeRules = [];
        edgeColorRules = [];
        colorIndex = 0;
        viewFilters = { onlyOrphans: false };
        isDirty = true;
        selectedNodeId = null;
        selectedEdgeId = null;
        clearSelectedNodeInUI();
        // Clear edge editor inputs
        edgeFromEl.value = '';
        edgeToEl.value = '';
        edgeFromInputEl.value = '';
        edgeToInputEl.value = '';
        refreshNodeSelects();
        updateTypeUI();
        updateAttributeListUI();
        updateNodeAttrValuesUI();
        updateEdgeAttrValuesUI();
        updateStyleRuleAttributeDropdowns();
        updateNodeShapeRulesUI();
        updateEdgeColorRulesUI();

        isIsolated = false;
        isolateSet = null;
        isolatedNodeId = null;

        applyVisibility();
        updateViewStateIndicator();
    });

    document.querySelector('#causal-editor #btnExportNodesCSV').addEventListener('click', function() {
        // Build header: Node, Type, then all node attributes
        const header = ['Node', 'Type'].concat(nodeAttributes);
        const rows = [header];
        nodesData.get().forEach(function(n) {
            const row = [n.rawLabel || n.label, n.type || ''];
            // Add attribute values for each attribute column
            nodeAttributes.forEach(function(attrName) {
                const attrs = n.attributes || {};
                row.push(attrs[attrName] || '');
            });
            rows.push(row);
        });
        downloadCSV(rows, 'nodes.csv');
        isDirty = false;
    });

    document.querySelector('#causal-editor #btnExportEdgesCSV').addEventListener('click', function() {
        // Build header: Node 1, Node 2, then all edge attributes
        const header = ['Node 1', 'Node 2'].concat(edgeAttributes);
        const rows = [header];
        const nodeMap = {};
        nodesData.get().forEach(function(n) {
            nodeMap[n.id] = n.rawLabel || n.label;
        });
        edgesData.get().forEach(function(e) {
            const row = [nodeMap[e.from] || e.from, nodeMap[e.to] || e.to];
            // Add attribute values for each attribute column
            edgeAttributes.forEach(function(attrName) {
                const attrs = e.attributes || {};
                row.push(attrs[attrName] || '');
            });
            rows.push(row);
        });
        downloadCSV(rows, 'edges.csv');
        isDirty = false;
    });

    document.querySelector('#causal-editor #btnAddType').addEventListener('click', function() {
        const name = newTypeNameEl.value.trim();
        if (!name) {
            alert('Please enter a type name.');
            return;
        }
        if (nodeTypes.has(name)) {
            alert('Type "' + name + '" already exists.');
            return;
        }
        addType(name);
        newTypeNameEl.value = '';
        isDirty = true;
    });

    // Attribute management handlers
    document.querySelector('#causal-editor #attrTargetType').addEventListener('change', function() {
        updateAttributeListUI();
    });

    document.querySelector('#causal-editor #btnAddAttr').addEventListener('click', function() {
        const targetType = document.querySelector('#causal-editor #attrTargetType').value;
        const attrName = document.querySelector('#causal-editor #newAttrName').value.trim();
        if (!attrName) {
            alert('Please enter an attribute name.');
            return;
        }
        const attrs = targetType === 'node' ? nodeAttributes : edgeAttributes;
        if (attrs.includes(attrName)) {
            alert('Attribute "' + attrName + '" already exists for ' + targetType + 's.');
            return;
        }
        addAttribute(targetType, attrName);
        document.querySelector('#causal-editor #newAttrName').value = '';
        isDirty = true;
    });

    // Style rule handlers
    document.querySelector('#causal-editor #btnAddNodeShapeRule').addEventListener('click', function() {
        const attrEl = document.querySelector('#causal-editor #nodeShapeAttr');
        const valueEl = document.querySelector('#causal-editor #nodeShapeValue');
        const shapeEl = document.querySelector('#causal-editor #nodeShapeShape');

        const attr = attrEl.value;
        const value = valueEl.value.trim();
        const shape = shapeEl.value;

        if (!attr) {
            alert('Please select an attribute.');
            return;
        }
        if (!value) {
            alert('Please enter a value to match.');
            return;
        }

        // Check for duplicate rule
        const exists = nodeShapeRules.some(function(r) {
            return r.attribute === attr && r.value === value;
        });
        if (exists) {
            alert('A shape rule for this attribute/value already exists.');
            return;
        }

        nodeShapeRules.push({ attribute: attr, value: value, shape: shape });
        updateNodeShapeRulesUI();
        valueEl.value = '';
        isDirty = true;
        applyVisibility();
    });

    document.querySelector('#causal-editor #btnAddEdgeColorRule').addEventListener('click', function() {
        const attrEl = document.querySelector('#causal-editor #edgeColorAttr');
        const valueEl = document.querySelector('#causal-editor #edgeColorValue');
        const colorEl = document.querySelector('#causal-editor #edgeColorColor');

        const attr = attrEl.value;
        const value = valueEl.value.trim();
        const color = colorEl.value;

        if (!attr) {
            alert('Please select an attribute.');
            return;
        }
        if (!value) {
            alert('Please enter a value to match.');
            return;
        }

        // Check for duplicate rule
        const exists = edgeColorRules.some(function(r) {
            return r.attribute === attr && r.value === value;
        });
        if (exists) {
            alert('A color rule for this attribute/value already exists.');
            return;
        }

        edgeColorRules.push({ attribute: attr, value: value, color: color });
        updateEdgeColorRulesUI();
        valueEl.value = '';
        isDirty = true;
        applyVisibility();
    });

    document.querySelector('#causal-editor #btnAddNode').addEventListener('click', function() {
        const label = createNodeLabelEl.value.trim();
        const type = createNodeTypeEl.value;
        if (!label) {
            alert('Please enter a label for the node.');
            return;
        }
        if (!type) {
            alert('Please select a type for the node.');
            return;
        }
        const id = slugifyLabel(label);
        const color = getTypeColor(type);
        nodesData.add({
            id: id,
            label: wrapLabel(label),
            rawLabel: label,
            type: type,
            attributes: {},
            baseColor: color,
            color: color
        });
        isDirty = true;
        refreshNodeSelects();
        createNodeLabelEl.value = '';
        selectedNodeId = id;
        selectNodeInUI(id);
        applyVisibility();
        // Focus on the new node after the graph is redrawn
        setTimeout(function() {
            focusOnNode(id);
        }, 100);
    });

    document.querySelector('#causal-editor #btnUpdateNode').addEventListener('click', function() {
        if (!selectedNodeId) {
            alert('Select a node in the graph first.');
            return;
        }
        const node = nodesData.get(selectedNodeId);
        if (!node) {
            alert('Selected node not found.');
            return;
        }

        const newRaw = editNodeLabelEl.value.trim() || node.rawLabel || node.label;
        const newType = editNodeTypeEl.value || node.type;
        const color = getTypeColor(newType);
        const newAttrs = getNodeAttrValuesFromUI();

        nodesData.update({
            id: node.id,
            label: wrapLabel(newRaw),
            rawLabel: newRaw,
            type: newType,
            attributes: newAttrs,
            baseColor: color,
            color: color
        });

        isDirty = true;
        refreshNodeSelects();
        selectNodeInUI(node.id);
        applyVisibility();
        // Maintain focus on the updated node
        setTimeout(function() {
            focusOnNode(node.id);
        }, 100);
    });

    document.querySelector('#causal-editor #btnDeleteNode').addEventListener('click', function() {
        if (!selectedNodeId) {
            alert('Select a node to delete.');
            return;
        }
        if (!confirm('Delete node and all connected edges?')) return;
        const edgesToRemove = edgesData.get({
            filter: function(e) { return e.from === selectedNodeId || e.to === selectedNodeId; }
        }).map(function(e) { return e.id; });
        if (edgesToRemove.length) edgesData.remove(edgesToRemove);
        nodesData.remove(selectedNodeId);
        isDirty = true;
        selectedNodeId = null;
        clearSelectedNodeInUI();
        refreshNodeSelects();
        applyVisibility();
    });

    document.querySelector('#causal-editor #btnAddEdge').addEventListener('click', function() {
        const fromId = edgeFromEl.value;
        const toId = edgeToEl.value;
        if (!fromId || !toId) {
            alert('Select both nodes.');
            return;
        }
        if (fromId === toId) {
            alert('Nodes must be different.');
            return;
        }

        // Check if edge already exists (either direction)
        const existing = edgesData.get({
            filter: function(e) {
                return (e.from === fromId && e.to === toId) ||
                       (e.from === toId && e.to === fromId);
            }
        });
        if (existing.length) {
            alert('An edge between these nodes already exists.');
            return;
        }

        const attrs = getEdgeAttrValuesFromUI();
        edgesData.add({ from: fromId, to: toId, attributes: attrs, color: '#666666' });
        isDirty = true;
        // Clear edge inputs after successful add
        edgeFromEl.value = '';
        edgeToEl.value = '';
        edgeFromInputEl.value = '';
        edgeToInputEl.value = '';
        updateEdgeAttrValuesUI();
        refreshNodeSelects();
        applyVisibility();
        // Focus on the target node after creating the edge
        setTimeout(function() {
            selectNodeInUI(toId);
            focusOnNode(toId);
        }, 100);
    });

    document.querySelector('#causal-editor #btnFocusNodeA').addEventListener('click', function() {
        const fromId = edgeFromEl.value;
        if (!fromId) {
            alert('No Node A selected.');
            return;
        }
        selectNodeInUI(fromId);
        focusOnNode(fromId);
    });

    document.querySelector('#causal-editor #btnUpdateEdge').addEventListener('click', function() {
        const fromId = edgeFromEl.value;
        const toId = edgeToEl.value;
        if (!fromId || !toId) {
            alert('Select both nodes to update the edge between them.');
            return;
        }

        // Find the existing edge between these nodes
        const existingEdges = edgesData.get({
            filter: function(e) {
                return (e.from === fromId && e.to === toId) ||
                       (e.from === toId && e.to === fromId);
            }
        });

        if (!existingEdges.length) {
            alert('No edge found between the selected nodes. Use "Add Edge" to create one.');
            return;
        }

        // Update the edge attributes
        const edge = existingEdges[0];
        const newAttrs = getEdgeAttrValuesFromUI();
        edgesData.update({
            id: edge.id,
            attributes: newAttrs
        });

        isDirty = true;
        applyVisibility();
    });

    document.querySelector('#causal-editor #btnDeleteEdge').addEventListener('click', function() {
        const fromId = edgeFromEl.value;
        const toId = edgeToEl.value;
        if (!fromId || !toId) {
            alert('Select both nodes to delete edges between them.');
            return;
        }
        const toDelete = edgesData.get({
            filter: function(e) {
                return (e.from === fromId && e.to === toId) ||
                       (e.from === toId && e.to === fromId);
            }
        }).map(function(e) { return e.id; });
        if (!toDelete.length) {
            alert('No edges found between the selected nodes.');
            return;
        }
        if (!confirm('Delete edge(s) between the selected nodes?')) return;
        edgesData.remove(toDelete);
        isDirty = true;
        // Clear edge inputs after successful delete
        edgeFromEl.value = '';
        edgeToEl.value = '';
        edgeFromInputEl.value = '';
        edgeToInputEl.value = '';
        refreshNodeSelects();
        applyVisibility();
    });

    document.querySelector('#causal-editor #btnIsolate').addEventListener('click', isolateSelectedNode);
    document.querySelector('#causal-editor #btnShowAll').addEventListener('click', showAll);

    sortMethodEl.addEventListener('change', function() {
        currentSortMethod = sortMethodEl.value;
        applyVisibility();
    });

    document.addEventListener('keydown', function(e) {
        if ((e.key === 'Delete' || e.key === 'Backspace') &&
            !(e.target && ['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName))) {
            deletePressed = true;
        }
    });
    document.addEventListener('keyup', function(e) {
        if (e.key === 'Delete' || e.key === 'Backspace') {
            deletePressed = false;
        }
    });

    function selectNodeInUI(id) {
        selectedNodeId = id;
        const node = nodesData.get(id);
        if (!node) {
            clearSelectedNodeInUI();
            return;
        }
        selectedNodeIdEl.textContent = node.rawLabel || node.label || id;
        editNodeLabelEl.value = node.rawLabel || node.label || '';
        editNodeTypeEl.value = node.type || '';

        if (isolateNodeDisplayEl) {
            isolateNodeDisplayEl.textContent = node.rawLabel || node.label || id;
        }

        if (!edgeFromEl.value) {
            edgeFromEl.value = id;
            edgeFromInputEl.value = node.rawLabel || node.label || id;
        }

        // Update node attribute values UI
        updateNodeAttrValuesUI();
    }

    function clearSelectedNodeInUI() {
        selectedNodeId = null;
        selectedNodeIdEl.textContent = 'None';
        if (isolateNodeDisplayEl) isolateNodeDisplayEl.textContent = 'None';
        updateNodeAttrValuesUI();
    }

    function updateViewStateIndicator() {
        const indicator = document.querySelector('#causal-editor #viewStateIndicator');
        const textEl = document.querySelector('#causal-editor #viewStateText');
        if (!indicator || !textEl) return;

        if (isIsolated && isolatedNodeId) {
            const node = nodesData.get(isolatedNodeId);
            const nodeName = node ? (node.rawLabel || node.label) : isolatedNodeId;
            textEl.textContent = 'Isolated: ' + nodeName;
            indicator.classList.add('isolated');
        } else {
            textEl.textContent = 'All nodes';
            indicator.classList.remove('isolated');
        }
    }

    function refreshNodeSelects() {
        // Validate that selected edge nodes still exist
        if (edgeFromEl.value && !nodesData.get(edgeFromEl.value)) {
            edgeFromEl.value = '';
            edgeFromInputEl.value = '';
        }
        if (edgeToEl.value && !nodesData.get(edgeToEl.value)) {
            edgeToEl.value = '';
            edgeToInputEl.value = '';
        }
    }

    // --- CSV Import/Export ---

    function parseCSV(text) {
        const lines = text.split(/\r?\n/);
        const rows = [];
        lines.forEach(function(line) {
            if (!line.trim()) return;
            // Simple CSV parsing (handles basic cases)
            const cells = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    cells.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            cells.push(current.trim());
            rows.push(cells);
        });
        return rows;
    }

    function handleCSVImport(nodesCSV, edgesCSV) {
        // Clear existing data
        nodesData.clear();
        edgesData.clear();
        nodeTypes.clear();
        nodeAttributes = [];
        edgeAttributes = [];
        nodeShapeRules = [];
        edgeColorRules = [];
        colorIndex = 0;
        viewFilters = { onlyOrphans: false };

        const nodeMap = {}; // label -> id

        // Parse nodes CSV
        if (nodesCSV) {
            const rows = parseCSV(nodesCSV);
            if (rows.length < 1) {
                // Empty file
            } else {
                // First row is header: Node, Type, Attr1, Attr2, ...
                const header = rows[0];
                // Columns beyond index 1 (Node, Type) are attribute names
                for (let c = 2; c < header.length; c++) {
                    const attrName = header[c].trim();
                    if (attrName && !nodeAttributes.includes(attrName)) {
                        nodeAttributes.push(attrName);
                    }
                }

                // Data rows
                for (let i = 1; i < rows.length; i++) {
                    const row = rows[i];
                    if (row.length < 2) continue;
                    const label = row[0];
                    const type = row[1];
                    if (!label) continue;

                    // Add type if new
                    if (type && !nodeTypes.has(type)) {
                        addType(type);
                    }

                    // Build attributes object from columns
                    const attrs = {};
                    for (let c = 2; c < header.length; c++) {
                        const attrName = header[c].trim();
                        const attrValue = (row[c] || '').trim();
                        if (attrName && attrValue) {
                            attrs[attrName] = attrValue;
                        }
                    }

                    const id = slugifyLabel(label);
                    const color = getTypeColor(type || 'Unknown');
                    nodeMap[label] = id;

                    nodesData.add({
                        id: id,
                        label: wrapLabel(label),
                        rawLabel: label,
                        type: type || 'Unknown',
                        attributes: attrs,
                        baseColor: color,
                        color: color
                    });
                }
            }
        }

        // Add Unknown type if needed
        const unknownNodes = nodesData.get({ filter: function(n) { return n.type === 'Unknown'; } });
        if (unknownNodes.length > 0 && !nodeTypes.has('Unknown')) {
            addType('Unknown', '#999999');
        }

        // Parse edges CSV
        if (edgesCSV) {
            const rows = parseCSV(edgesCSV);
            if (rows.length < 1) {
                // Empty file
            } else {
                // First row is header: Node 1, Node 2, Attr1, Attr2, ...
                const header = rows[0];
                // Columns beyond index 1 (Node 1, Node 2) are attribute names
                for (let c = 2; c < header.length; c++) {
                    const attrName = header[c].trim();
                    if (attrName && !edgeAttributes.includes(attrName)) {
                        edgeAttributes.push(attrName);
                    }
                }

                // Data rows
                for (let i = 1; i < rows.length; i++) {
                    const row = rows[i];
                    if (row.length < 2) continue;
                    const label1 = row[0];
                    const label2 = row[1];
                    if (!label1 || !label2) continue;

                    let id1 = nodeMap[label1];
                    let id2 = nodeMap[label2];

                    // Create nodes if they don't exist (from edges file)
                    if (!id1) {
                        id1 = slugifyLabel(label1);
                        nodeMap[label1] = id1;
                        if (!nodeTypes.has('Unknown')) {
                            addType('Unknown', '#999999');
                        }
                        nodesData.add({
                            id: id1,
                            label: wrapLabel(label1),
                            rawLabel: label1,
                            type: 'Unknown',
                            attributes: {},
                            baseColor: '#999999',
                            color: '#999999'
                        });
                    }
                    if (!id2) {
                        id2 = slugifyLabel(label2);
                        nodeMap[label2] = id2;
                        if (!nodeTypes.has('Unknown')) {
                            addType('Unknown', '#999999');
                        }
                        nodesData.add({
                            id: id2,
                            label: wrapLabel(label2),
                            rawLabel: label2,
                            type: 'Unknown',
                            attributes: {},
                            baseColor: '#999999',
                            color: '#999999'
                        });
                    }

                    // Build edge attributes object from columns
                    const attrs = {};
                    for (let c = 2; c < header.length; c++) {
                        const attrName = header[c].trim();
                        const attrValue = (row[c] || '').trim();
                        if (attrName && attrValue) {
                            attrs[attrName] = attrValue;
                        }
                    }

                    // Check if edge already exists
                    const existing = edgesData.get({
                        filter: function(e) {
                            return (e.from === id1 && e.to === id2) ||
                                   (e.from === id2 && e.to === id1);
                        }
                    });
                    if (!existing.length) {
                        edgesData.add({ from: id1, to: id2, attributes: attrs, color: '#666666' });
                    }
                }
            }
        }

        isDirty = true;
        selectedNodeId = null;
        selectedEdgeId = null;
        clearSelectedNodeInUI();
        refreshNodeSelects();
        updateTypeUI();
        updateAttributeListUI();
        updateNodeAttrValuesUI();
        updateEdgeAttrValuesUI();
        updateStyleRuleAttributeDropdowns();
        updateNodeShapeRulesUI();
        updateEdgeColorRulesUI();

        isIsolated = false;
        isolateSet = null;
        isolatedNodeId = null;

        applyVisibility();
        updateViewStateIndicator();

        const nodeCount = nodesData.get().length;
        const edgeCount = edgesData.get().length;
        const typeCount = nodeTypes.size;
        const nodeAttrCount = nodeAttributes.length;
        const edgeAttrCount = edgeAttributes.length;
        alert('Import complete: ' + nodeCount + ' nodes, ' + edgeCount + ' edges, ' + typeCount + ' types.\n' +
              'Node attributes: ' + nodeAttrCount + ', Edge attributes: ' + edgeAttrCount);
    }

    function downloadCSV(rows, filename) {
        const csvContent = rows.map(function(row) {
            return row.map(function(cell) {
                // Escape quotes and wrap in quotes if contains comma or quote
                const str = String(cell || '');
                if (str.indexOf(',') >= 0 || str.indexOf('"') >= 0 || str.indexOf('\n') >= 0) {
                    return '"' + str.replace(/"/g, '""') + '"';
                }
                return str;
            }).join(',');
        }).join('\n');

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
    }

    // Warn on tab close / navigation if there are unsaved changes
    window.addEventListener('beforeunload', function(e) {
        if (!isDirty) return;
        e.preventDefault();
        e.returnValue = '';
        return '';
    });

    window.addEventListener('load', function() {
        sortMethodEl.value = 'alpha';
        currentSortMethod = 'alpha';
        updateTypeUI();
        updateAttributeListUI();
        updateNodeAttrValuesUI();
        updateEdgeAttrValuesUI();
        updateStyleRuleAttributeDropdowns();
        updateNodeShapeRulesUI();
        updateEdgeColorRulesUI();
        applyVisibility();
    });

    // Node search with typeahead
    const nodeSearchEl = document.querySelector('#causal-editor #nodeSearch');
    const searchResultsEl = document.querySelector('#causal-editor #searchResults');
    let searchHighlightIndex = -1;

    function updateSearchResults(query) {
        searchResultsEl.innerHTML = '';
        searchHighlightIndex = -1;

        if (!query || query.length < 1) {
            searchResultsEl.classList.remove('active');
            return;
        }

        const lowerQuery = query.toLowerCase();
        const matches = nodesData.get().filter(function(n) {
            const label = (n.rawLabel || n.label || '').toLowerCase();
            return label.includes(lowerQuery);
        }).slice(0, 20); // Limit to 20 results

        if (matches.length === 0) {
            searchResultsEl.classList.remove('active');
            return;
        }

        matches.forEach(function(n, idx) {
            const div = document.createElement('div');
            div.className = 'search-result-item';
            div.dataset.nodeId = n.id;

            const dot = document.createElement('span');
            dot.className = 'search-result-dot';
            dot.style.backgroundColor = getTypeColor(n.type);

            const label = document.createElement('span');
            label.className = 'search-result-label';
            label.textContent = n.rawLabel || n.label;

            const type = document.createElement('span');
            type.className = 'search-result-type';
            type.textContent = n.type || '';

            div.appendChild(dot);
            div.appendChild(label);
            div.appendChild(type);

            div.addEventListener('click', function() {
                selectSearchResult(n.id);
            });

            searchResultsEl.appendChild(div);
        });

        searchResultsEl.classList.add('active');
    }

    function selectSearchResult(nodeId) {
        nodeSearchEl.value = '';
        searchResultsEl.classList.remove('active');
        searchResultsEl.innerHTML = '';

        // Select the node in UI
        selectNodeInUI(nodeId);

        // Focus on the node in the network
        if (network && networkNodes && networkNodes.get(nodeId)) {
            network.selectNodes([nodeId]);
            network.focus(nodeId, {
                scale: 1.5,
                animation: {
                    duration: 500,
                    easingFunction: 'easeInOutQuad'
                }
            });
        }
    }

    function highlightSearchResult(index) {
        const items = searchResultsEl.querySelectorAll('.search-result-item');
        items.forEach(function(item, i) {
            if (i === index) {
                item.classList.add('highlighted');
                item.scrollIntoView({ block: 'nearest' });
            } else {
                item.classList.remove('highlighted');
            }
        });
    }

    nodeSearchEl.addEventListener('input', function() {
        updateSearchResults(nodeSearchEl.value.trim());
    });

    nodeSearchEl.addEventListener('keydown', function(e) {
        const items = searchResultsEl.querySelectorAll('.search-result-item');
        if (!items.length) return;

        if (e.key === 'ArrowDown') {
            e.preventDefault();
            searchHighlightIndex = Math.min(searchHighlightIndex + 1, items.length - 1);
            highlightSearchResult(searchHighlightIndex);
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            searchHighlightIndex = Math.max(searchHighlightIndex - 1, 0);
            highlightSearchResult(searchHighlightIndex);
        } else if (e.key === 'Enter') {
            e.preventDefault();
            if (searchHighlightIndex >= 0 && items[searchHighlightIndex]) {
                const nodeId = items[searchHighlightIndex].dataset.nodeId;
                selectSearchResult(nodeId);
            } else if (items.length > 0) {
                const nodeId = items[0].dataset.nodeId;
                selectSearchResult(nodeId);
            }
        } else if (e.key === 'Escape') {
            searchResultsEl.classList.remove('active');
            nodeSearchEl.blur();
        }
    });

    nodeSearchEl.addEventListener('blur', function() {
        // Delay to allow click on result
        setTimeout(function() {
            searchResultsEl.classList.remove('active');
        }, 200);
    });

    nodeSearchEl.addEventListener('focus', function() {
        if (nodeSearchEl.value.trim()) {
            updateSearchResults(nodeSearchEl.value.trim());
        }
    });

    // --- Edge Editor Typeahead ---

    function setupEdgeTypeahead(inputEl, hiddenEl, resultsEl) {
        let highlightIndex = -1;

        function updateResults(query) {
            resultsEl.innerHTML = '';
            highlightIndex = -1;

            if (!query || query.length < 1) {
                resultsEl.classList.remove('active');
                return;
            }

            const lowerQuery = query.toLowerCase();
            const matches = nodesData.get().filter(function(n) {
                const label = (n.rawLabel || n.label || '').toLowerCase();
                return label.includes(lowerQuery);
            }).slice(0, 15);

            if (matches.length === 0) {
                resultsEl.classList.remove('active');
                return;
            }

            matches.forEach(function(n) {
                const div = document.createElement('div');
                div.className = 'search-result-item';
                div.dataset.nodeId = n.id;

                const dot = document.createElement('span');
                dot.className = 'search-result-dot';
                dot.style.backgroundColor = getTypeColor(n.type);

                const label = document.createElement('span');
                label.className = 'search-result-label';
                label.textContent = n.rawLabel || n.label;

                const type = document.createElement('span');
                type.className = 'search-result-type';
                type.textContent = n.type || '';

                div.appendChild(dot);
                div.appendChild(label);
                div.appendChild(type);

                div.addEventListener('click', function() {
                    selectResult(n.id, n.rawLabel || n.label);
                });

                resultsEl.appendChild(div);
            });

            resultsEl.classList.add('active');
        }

        function selectResult(nodeId, nodeLabel) {
            hiddenEl.value = nodeId;
            inputEl.value = nodeLabel;
            resultsEl.classList.remove('active');
            resultsEl.innerHTML = '';
        }

        function highlightResult(index) {
            const items = resultsEl.querySelectorAll('.search-result-item');
            items.forEach(function(item, i) {
                if (i === index) {
                    item.classList.add('highlighted');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('highlighted');
                }
            });
        }

        inputEl.addEventListener('input', function() {
            // Clear the hidden value when typing (will be set on selection)
            hiddenEl.value = '';
            updateResults(inputEl.value.trim());
        });

        inputEl.addEventListener('keydown', function(e) {
            const items = resultsEl.querySelectorAll('.search-result-item');
            if (!items.length) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                highlightIndex = Math.min(highlightIndex + 1, items.length - 1);
                highlightResult(highlightIndex);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                highlightIndex = Math.max(highlightIndex - 1, 0);
                highlightResult(highlightIndex);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (highlightIndex >= 0 && items[highlightIndex]) {
                    const nodeId = items[highlightIndex].dataset.nodeId;
                    const node = nodesData.get(nodeId);
                    selectResult(nodeId, node ? (node.rawLabel || node.label) : nodeId);
                } else if (items.length > 0) {
                    const nodeId = items[0].dataset.nodeId;
                    const node = nodesData.get(nodeId);
                    selectResult(nodeId, node ? (node.rawLabel || node.label) : nodeId);
                }
            } else if (e.key === 'Escape') {
                resultsEl.classList.remove('active');
            }
        });

        inputEl.addEventListener('blur', function() {
            setTimeout(function() {
                resultsEl.classList.remove('active');
            }, 200);
        });

        inputEl.addEventListener('focus', function() {
            if (inputEl.value.trim() && !hiddenEl.value) {
                updateResults(inputEl.value.trim());
            }
        });
    }

    // Initialize edge typeaheads
    setupEdgeTypeahead(edgeFromInputEl, edgeFromEl, edgeFromResultsEl);
    setupEdgeTypeahead(edgeToInputEl, edgeToEl, edgeToResultsEl);

    // Help modal
    const helpModal = document.querySelector('#causal-editor #helpModal');
    document.querySelector('#causal-editor #btnHelp').addEventListener('click', function() {
        helpModal.classList.add('visible');
    });
    document.querySelector('#causal-editor #btnCloseHelp').addEventListener('click', function() {
        helpModal.classList.remove('visible');
    });
    helpModal.addEventListener('click', function(e) {
        if (e.target === helpModal) {
            helpModal.classList.remove('visible');
        }
    });
</script>
