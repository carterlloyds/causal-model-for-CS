//casual model for CS
<style>
    /* Hard encapsulation: everything inside #causal-editor */
    #causal-editor,
    #causal-editor * {
        box-sizing: border-box !important;
        font-family: Arial, sans-serif !important;
    }

    #causal-editor {
        height: 80vh !important;
        width: 100% !important;
        background: #ffffff !important;
        color: #111111 !important;
    }

    #causal-editor a {
        color: #0056B3 !important;
        text-decoration: none !important;
    }

    #causal-editor a:hover {
        text-decoration: underline !important;
    }

    #causal-editor #app {
        display: flex !important;
        height: 100% !important;
        width: 100% !important;
    }

    #causal-editor #sidebar {
        width: 340px !important;
        min-width: 260px !important;
        max-width: 440px !important;
        border-right: 1px solid #dddddd !important;
        background: #f7f7f7 !important;
        padding: 12px !important;
        overflow-y: auto !important;
    }

    #causal-editor #main {
        flex: 1 !important;
        display: flex !important;
        flex-direction: column !important;
        padding: 8px !important;
        background: #ffffff !important;
    }

    #causal-editor #network {
        flex: 1 !important;
        min-height: 400px !important;
        border: 1px solid #cccccc !important;
        background: #ffffff !important;
    }

    #causal-editor h1,
    #causal-editor h2,
    #causal-editor h3,
    #causal-editor h4,
    #causal-editor h5,
    #causal-editor h6 {
        margin-top: 0 !important;
        margin-bottom: 6px !important;
        font-weight: 600 !important;
        color: #111111 !important;
    }

    #causal-editor h2 {
        font-size: 18px !important;
    }

    #causal-editor h3 {
        font-size: 14px !important;
        border-bottom: 1px solid #dddddd !important;
        padding-bottom: 2px !important;
    }

    #causal-editor label {
        font-size: 12px !important;
        display: block !important;
        margin-bottom: 3px !important;
        color: #333333 !important;
    }

    #causal-editor input[type="text"],
    #causal-editor input[type="file"],
    #causal-editor select,
    #causal-editor textarea {
        width: 100% !important;
        font-size: 12px !important;
        padding: 4px 6px !important;
        margin-bottom: 8px !important;
        border-radius: 3px !important;
        border: 1px solid #cccccc !important;
        background: #ffffff !important;
        color: #111111 !important;
        box-shadow: none !important;
        outline: none !important;
    }

    #causal-editor input[type="file"] {
        padding: 2px !important;
    }

    #causal-editor textarea {
        resize: vertical !important;
    }

    #causal-editor button {
        font-size: 12px !important;
        padding: 5px 8px !important;
        margin: 2px 0 !important;
        border-radius: 4px !important;
        border: 1px solid #999999 !important;
        background: #ffffff !important;
        color: #111111 !important;
        cursor: pointer !important;
        box-shadow: none !important;
        display: inline-block !important;
        line-height: 1.3 !important;
    }

    #causal-editor button.primary {
        background: #0056B3 !important;
        color: #ffffff !important;
        border-color: #00408a !important;
    }

    #causal-editor button.danger {
        background: #c0392b !important;
        color: #ffffff !important;
        border-color: #a5281b !important;
    }

    #causal-editor button:disabled {
        opacity: 0.5 !important;
        cursor: default !important;
    }

    #causal-editor .button-row {
        display: flex !important;
        flex-wrap: wrap !important;
        gap: 4px !important;
        margin-bottom: 8px !important;
    }

    #causal-editor .small {
        font-size: 11px !important;
        color: #555555 !important;
    }

    #causal-editor .inline-file {
        font-size: 11px !important;
        margin-bottom: 8px !important;
    }

    #causal-editor .tag-row {
        display: flex !important;
        flex-wrap: wrap !important;
        gap: 4px !important;
        margin-bottom: 4px !important;
    }

    #causal-editor .tag {
        padding: 4px 8px !important;
        border-radius: 999px !important;
        font-size: 11px !important;
        border: 2px solid #cccccc !important;
        background: #ffffff !important;
        color: #111111 !important;
        white-space: nowrap !important;
    }

    #causal-editor .tag.symptom    { border-color: red !important;    color: red !important; }
    #causal-editor .tag.rootcause  { border-color: blue !important;   color: blue !important; }
    #causal-editor .tag.capability { border-color: green !important;  color: green !important; }
    #causal-editor .tag.solution   { border-color: purple !important; color: purple !important; }

    #causal-editor .section {
        margin-bottom: 12px !important;
    }

    #causal-editor #selectedNodeSummary {
        font-size: 11px !important;
        padding: 4px !important;
        background: #eeeeee !important;
        border-radius: 4px !important;
        margin-bottom: 6px !important;
    }

    #causal-editor #exportText {
        font-family: Menlo, Monaco, Consolas, "Courier New", monospace !important;
        font-size: 11px !important;
    }

    #causal-editor .type-label {
        display: flex !important;
        align-items: center !important;
        gap: 6px !important;
        font-size: 12px !important;
        margin-bottom: 2px !important;
    }

    #causal-editor .type-label input {
        margin: 0 !important;
        width: auto !important;
    }

    #causal-editor .filters {
        margin-top: 4px !important;
        margin-bottom: 4px !important;
    }

    #causal-editor #indeavor-logo {
        max-width: 160px !important;
        margin-bottom: 6px !important;
        display: block !important;
    }

    @media (max-width: 900px) {
        #causal-editor #app {
            flex-direction: column !important;
        }
        #causal-editor #sidebar {
            width: 100% !important;
            max-height: 52vh !important;
            border-right: none !important;
            border-bottom: 1px solid #dddddd !important;
        }
        #causal-editor #main {
            padding: 4px !important;
        }
    }
</style>

<div id="causal-editor">
    <div id="app">
        <div id="sidebar">
            <img id="indeavor-logo" src="https://www.indeavor.com/wp-content/uploads/2024/09/indeavor-logo.svg" alt="Indeavor logo">
            <h2>Causal Model Editor</h2>
            <div class="tag-row">
                <span class="tag symptom">Symptom (red)</span>
                <span class="tag rootcause">Root Cause (blue)</span>
                <span class="tag capability">Capability (green)</span>
                <span class="tag solution">Solution (purple)</span>
            </div>

            <!-- Import / Export -->
            <div class="section">
                <h3>Import / Export</h3>
                <label for="importText">Paste full HTML or data.js block:</label>
                <textarea id="importText" rows="6" placeholder="Paste your existing HTML file or the window.nodes / window.edges data.js block here…"></textarea>
                <div class="button-row">
                    <button id="btnImportText" class="primary">Import from Text</button>
                    <button id="btnClear">New / Clear Graph</button>
                </div>
                <div class="inline-file">
                    <label for="importFile">Or upload HTML/JS file:</label>
                    <input type="file" id="importFile" accept=".html,.htm,.js,.txt">
                </div>

                <div class="inline-file">
                    <button id="btnImportFromWeb">Import current model from web</button>
                </div>

                <div class="button-row" style="margin-top:4px;">
                    <button id="btnExport" class="primary">Export data.js</button>
                    <button id="btnDownloadData">Download data.js</button>
                </div>
                <label for="exportText" class="small">Exported code (window.nodes / window.edges):</label>
                <textarea id="exportText" rows="6" readonly placeholder="Click 'Export data.js' to generate embeddable code…"></textarea>
            </div>

            <!-- Create Node -->
            <div class="section">
                <h3>Create Node</h3>
                <label for="createNodeLabel">Label</label>
                <input type="text" id="createNodeLabel" placeholder="New node label…">

                <label for="createNodeType">Type</label>
                <select id="createNodeType">
                    <option value="Symptom">Symptom (red)</option>
                    <option value="Root Cause">Root Cause (blue)</option>
                    <option value="Capability">Capability (green)</option>
                    <option value="Solution">Solution (purple)</option>
                </select>

                <div class="button-row">
                    <button id="btnAddNode" class="primary">Add Node</button>
                </div>
                <div class="small">
                    New node IDs are auto-generated and compatible with the exported data.js format.
                </div>
            </div>

            <!-- Edit Node -->
            <div class="section">
                <h3>Edit Node</h3>
                <div id="selectedNodeSummary">
                    Selected node: <strong><span id="selectedNodeId">None</span></strong>
                </div>

                <label for="editNodeLabel">Label</label>
                <input type="text" id="editNodeLabel" placeholder="Edit label of selected node…">

                <label for="editNodeType">Type</label>
                <select id="editNodeType">
                    <option value="Symptom">Symptom (red)</option>
                    <option value="Root Cause">Root Cause (blue)</option>
                    <option value="Capability">Capability (green)</option>
                    <option value="Solution">Solution (purple)</option>
                </select>

                <div class="button-row">
                    <button id="btnUpdateNode">Update Selected Node</button>
                    <button id="btnDeleteNode" class="danger">Delete Selected Node</button>
                </div>
                <div class="small">
                    Click a node in the graph to select it for editing.
                </div>
            </div>

            <!-- Edge editor -->
            <div class="section">
                <h3>Edge Editor</h3>
                <label for="edgeFrom">From (upstream)</label>
                <select id="edgeFrom">
                    <option value="">-- select --</option>
                </select>

                <label for="edgeTo">To (downstream)</label>
                <select id="edgeTo">
                    <option value="">-- select --</option>
                </select>

                <div class="button-row">
                    <button id="btnAddEdge" class="primary">Add Edge</button>
                    <button id="btnDeleteEdge" class="danger">Delete Edge(s)</button>
                </div>
                <div class="small">
                    Hierarchy enforced: Symptom → Root Cause → Capability → Solution.<br>
                    You can also:<br>
                    • Hold <strong>Shift</strong> and click two nodes to create an edge (any order).<br>
                    • Hold <strong>Delete</strong> and click an edge to delete it.
                </div>
            </div>

            <!-- View / Behavior -->
            <div class="section">
                <h3>View & Behavior</h3>

                <div id="isolateSelectedSummary" class="small" style="margin-bottom:4px;">
                    Selected for isolate: <strong><span id="isolateNodeDisplay">None</span></strong>
                </div>

                <div class="button-row">
                    <button id="btnIsolate">Isolate Selected Node</button>
                    <button id="btnFocusNeighbors">Layer Focus (Edit)</button>
                    <button id="btnShowAll">Show All</button>
                </div>

                <div class="filters">
                    <label class="type-label">
                        <input type="checkbox" id="filterSymptom" checked>
                        Symptom (<span id="countSymptom">0</span>)
                    </label>
                    <label class="type-label">
                        <input type="checkbox" id="filterRootCause" checked>
                        Root Cause (<span id="countRootCause">0</span>)
                    </label>
                    <label class="type-label">
                        <input type="checkbox" id="filterCapability" checked>
                        Capability (<span id="countCapability">0</span>)
                    </label>
                    <label class="type-label">
                        <input type="checkbox" id="filterSolution" checked>
                        Solution (<span id="countSolution">0</span>)
                    </label>
                    <label class="type-label">
                        <input type="checkbox" id="onlyOrphans">
                        Only Orphans (<span id="countOrphans">0</span>)
                    </label>
                </div>

                <label for="sortMethod" class="small">Sort method for all views:</label>
                <select id="sortMethod">
                    <option value="directed">Directed (vis default)</option>
                    <option value="alpha">Alphabetical by label</option>
                </select>

                <div class="small" style="margin-top:4px;">
                    Orphans are nodes with no edges in the full graph. They are counted both under their node type and as orphans.<br>
                    Orphans in the current view blink between their type color and white.<br>
                    Layer Focus defaults to <strong>Alphabetical</strong>.
                </div>
            </div>
        </div>

        <div id="main">
            <div id="network"></div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
<script>
    const TYPE_INFO = {
        'Symptom':     { color: 'red',    level: 0 },
        'Root Cause':  { color: 'blue',   level: 1 },
        'Capability':  { color: 'green',  level: 2 },
        'Solution':    { color: 'purple', level: 3 }
    };

    const TYPE_ISOLATION_CONFIG = {
        'Symptom':    { up: 0, down: 3 },
        'Root Cause': { up: 1, down: 2 },
        'Capability': { up: 2, down: 1 },
        'Solution':   { up: 3, down: 0 }
    };

    let nodesData = new vis.DataSet([]);
    let edgesData = new vis.DataSet([]);

    let networkNodes = null; // view-only
    let networkEdges = null;
    let network = null;

    let selectedNodeId = null;
    let isolatedNodeId = null;
    let edgeCreationSourceId = null;
    let deletePressed = false;

    let isIsolated = false;
    let isolateSet = null;

    let focusMode = false;
    let focusType = null;
    let focusNodeId = null;

    // sortMethod: 'directed' | 'alpha'
    let currentSortMethod = 'directed';

    let viewFilters = {
        'Symptom': true,
        'Root Cause': true,
        'Capability': true,
        'Solution': true,
        onlyOrphans: false
    };

    let blinkInterval = null;
    let blinkingIds = new Set();

    // track unsaved changes (for beforeunload warning)
    let isDirty = false;

    // --- Helpers ---------------------------------------------------------

    function wrapLabel(text, maxLen) {
        if (maxLen === undefined) maxLen = 22;
        if (!text) return '';
        const words = String(text).split(/\s+/);
        const lines = [];
        let line = '';
        words.forEach(function(word) {
            const candidate = (line ? line + ' ' : '') + word;
            if (candidate.length > maxLen) {
                if (line) lines.push(line);
                line = word;
            } else {
                line = candidate;
            }
        });
        if (line) lines.push(line);
        return lines.join('\n');
    }

    function getTypeFromNode(node) {
        if (node.type && TYPE_INFO[node.type]) return node.type;
        const c = node.baseColor || node.color;
        if (c === 'red')    return 'Symptom';
        if (c === 'blue')   return 'Root Cause';
        if (c === 'green')  return 'Capability';
        if (c === 'purple') return 'Solution';
        return 'Symptom';
    }

    function canConnectTypes(fromType, toType) {
        const fromInfo = TYPE_INFO[fromType];
        const toInfo   = TYPE_INFO[toType];
        if (!fromInfo || !toInfo) return false;
        return (toInfo.level - fromInfo.level) === 1;
    }

    function slugifyLabel(label) {
        let slug = label.trim().replace(/[\s]+/g, '_');
        slug = slug.replace(/[^A-Za-z0-9_]/g, '_');
        if (!slug) slug = 'node';
        const base = slug;
        let counter = 1;
        while (nodesData.get(slug)) {
            slug = base + '_' + counter;
            counter++;
        }
        return slug;
    }

    function recomputeLevelsAndColors() {
        const updates = [];
        nodesData.get().forEach(function(n) {
            const type = getTypeFromNode(n);
            const info = TYPE_INFO[type] || {};
            const baseColor = n.baseColor || n.color || info.color || 'gray';
            updates.push({
                id: n.id,
                type: type,
                baseColor: baseColor,
                color: baseColor,
                level: info.level != null ? info.level : 4
            });
        });
        if (updates.length) nodesData.update(updates);
    }

    // Remove any edge that doesn't connect adjacent levels
    function enforceValidEdges() {
        const toRemove = [];
        edgesData.get().forEach(function(e) {
            const fromNode = nodesData.get(e.from);
            const toNode   = nodesData.get(e.to);
            if (!fromNode || !toNode) {
                toRemove.push(e.id);
                return;
            }
            const ft = getTypeFromNode(fromNode);
            const tt = getTypeFromNode(toNode);
            if (!canConnectTypes(ft, tt)) {
                toRemove.push(e.id);
            }
        });
        if (toRemove.length) edgesData.remove(toRemove);
    }

    // --- Alpha layout for any view --------------------------------------

    function applyAlphaLayout(viewNodesArr) {
        if (!viewNodesArr.length) return;

        const levelSet = new Set();
        viewNodesArr.forEach(function(n) {
            const t = n.type || getTypeFromNode(n);
            const info = TYPE_INFO[t] || {};
            const lvl = info.level != null ? info.level : 0;
            n.level = lvl;
            levelSet.add(lvl);
        });

        const levels = Array.from(levelSet).sort(function(a, b) { return a - b; });
        const verticalSpacing = 180;
        const horizontalSpacing = 160;

        levels.forEach(function(lvl, idx) {
            const band = viewNodesArr.filter(function(n) { return n.level === lvl; });

            band.sort(function(a, b) {
                const la = (a.rawLabel || a.label || '').replace(/\n/g, ' ').toLowerCase();
                const lb = (b.rawLabel || b.label || '').replace(/\n/g, ' ').toLowerCase();
                if (la < lb) return -1;
                if (la > lb) return 1;
                return 0;
            });

            const count = band.length;
            if (!count) return;

            const startX = -((count - 1) * horizontalSpacing) / 2;
            const y = (idx - (levels.length - 1) / 2) * verticalSpacing;

            band.forEach(function(n, i) {
                n.x = startX + i * horizontalSpacing;
                n.y = y;
                n.fixed = { x: true, y: true };
            });
        });
    }

    // --- Drawing & visibility -------------------------------------------

    function drawNetwork(viewNodesArr, viewEdgesArr) {
        const container = document.querySelector('#causal-editor #network');

        const useHierarchical = (currentSortMethod === 'directed');

        networkNodes = new vis.DataSet(viewNodesArr);
        networkEdges = new vis.DataSet(viewEdgesArr);

        const data = { nodes: networkNodes, edges: networkEdges };

        const options = {
            layout: useHierarchical ? {
                hierarchical: {
                    enabled: true,
                    direction: 'UD',
                    sortMethod: 'directed',
                    levelSeparation: 200,
                    nodeSpacing: 170,
                    treeSpacing: 260,
                    blockShifting: true,
                    edgeMinimization: true,
                    parentCentralization: true
                }
            } : {},
            physics: { enabled: false },
            nodes: {
                shape: 'dot',
                size: 20,
                font: { size: 12, align: 'center', multi: 'md' },
                scaling: { label: { enabled: true, min: 10, max: 16 } },
                widthConstraint: { maximum: 200 }
            },
            edges: { arrows: { to: { enabled: false } }, color: '#666666' },
            interaction: { dragNodes: true, dragView: true, zoomView: true, hover: true }
        };

        if (network) network.destroy();
        network = new vis.Network(container, data, options);

        network.on('click', function(params) {
            const srcEvent = params.event && params.event.srcEvent;
            const shift = srcEvent && srcEvent.shiftKey;

            // Edge click: update edge editor dropdowns
            if (params.edges && params.edges.length && (!params.nodes || !params.nodes.length)) {
                const edgeId = params.edges[0];
                const e = networkEdges.get(edgeId);
                if (e) {
                    edgeFromEl.value = String(e.from);
                    edgeToEl.value   = String(e.to);
                }

                if (deletePressed) {
                    handleEdgeDeleteClick(params.edges);
                    return;
                }
            }

            // Shift+click nodes => edge creation
            if (shift && params.nodes && params.nodes.length) {
                handleShiftNodeClick(params.nodes[0]);
                return;
            }

            if (params.nodes && params.nodes.length) {
                selectNodeInUI(params.nodes[0]);
            } else {
                clearSelectedNodeInUI();
            }
        });

        network.on('doubleClick', function(params) {
            if (!params.nodes || !params.nodes.length) return;
            const nodeId = params.nodes[0];

            const mode = focusMode ? 'layer' : (isIsolated ? 'isolated' : 'showAll');

            if (mode === 'showAll') {
                // Show All -> Isolate on that node
                selectNodeInUI(nodeId);
                isolateSelectedNode();
            } else if (mode === 'isolated') {
                // Isolated mode
                if (isolatedNodeId && nodeId === isolatedNodeId) {
                    // dbl-click isolated node -> Layer Focus
                    selectNodeInUI(nodeId);
                    focusNeighbors();
                } else {
                    // dbl-click other node -> isolate that node instead
                    selectNodeInUI(nodeId);
                    isolateSelectedNode();
                }
            } else if (mode === 'layer') {
                // Layer Focus mode
                if (focusNodeId && nodeId === focusNodeId) {
                    // dbl-click focal node -> Show All
                    showAll();
                } else {
                    // dbl-click other node -> Layer Focus with new focal
                    selectNodeInUI(nodeId);
                    focusNeighbors();
                }
            }
        });

        network.fit({ animation: false });
    }

    function updateBlinking(degreeMap, visibleNodeIds) {
        if (blinkInterval) {
            clearInterval(blinkInterval);
            blinkInterval = null;
        }
        blinkingIds = new Set();
        if (!networkNodes) return;

        Object.keys(degreeMap).forEach(function(id) {
            if (degreeMap[id] === 0 && visibleNodeIds.has(id)) {
                blinkingIds.add(id);
            }
        });

        if (!blinkingIds.size) return;

        let blinkOn = false;
        blinkInterval = setInterval(function() {
            const updates = [];
            blinkingIds.forEach(function(id) {
                const n = networkNodes.get(id);
                if (!n) return;
                const base = n.baseColor || n.color || 'gray';
                updates.push({ id: id, color: blinkOn ? '#ffffff' : base });
            });
            if (updates.length) networkNodes.update(updates);
            blinkOn = !blinkOn;
        }, 800);
    }

    const countSymptomEl    = document.querySelector('#causal-editor #countSymptom');
    const countRootCauseEl  = document.querySelector('#causal-editor #countRootCause');
    const countCapabilityEl = document.querySelector('#causal-editor #countCapability');
    const countSolutionEl   = document.querySelector('#causal-editor #countSolution');
    const countOrphansEl    = document.querySelector('#causal-editor #countOrphans');

    function updateCounts(degreeMap) {
        const counts = { 'Symptom': 0, 'Root Cause': 0, 'Capability': 0, 'Solution': 0 };
        nodesData.get().forEach(function(n) {
            const t = getTypeFromNode(n);
            if (counts[t] != null) counts[t]++;
        });
        countSymptomEl.textContent    = counts['Symptom'];
        countRootCauseEl.textContent  = counts['Root Cause'];
        countCapabilityEl.textContent = counts['Capability'];
        countSolutionEl.textContent   = counts['Solution'];

        let orphanCount = 0;
        Object.keys(degreeMap).forEach(function(id) {
            if (degreeMap[id] === 0) orphanCount++;
        });
        countOrphansEl.textContent = orphanCount;
    }

    function applyVisibility() {
        recomputeLevelsAndColors();
        enforceValidEdges();

        // degreeMap on FULL graph
        const degreeMap = {};
        nodesData.get().forEach(function(n) { degreeMap[n.id] = 0; });
        edgesData.get().forEach(function(e) {
            if (degreeMap[e.from] != null) degreeMap[e.from]++;
            if (degreeMap[e.to]   != null) degreeMap[e.to]++;
        });

        const visibleNodeIds = new Set();

        if (focusMode && focusNodeId && focusType && TYPE_INFO[focusType]) {
            const selectedLevel = TYPE_INFO[focusType].level;
            nodesData.get().forEach(function(n) {
                const id = n.id;
                const t = getTypeFromNode(n);
                const info = TYPE_INFO[t] || {};
                const lvl = info.level != null ? info.level : -1;

                let visible;
                if (id === focusNodeId) {
                    visible = true;
                } else if (lvl === selectedLevel) {
                    visible = false; // hide other nodes of same type
                } else if (lvl === selectedLevel - 1 || lvl === selectedLevel + 1) {
                    visible = true;
                } else {
                    visible = false;
                }

                if (visible) visibleNodeIds.add(id);
            });
        } else {
            nodesData.get().forEach(function(n) {
                const id = n.id;
                let visible = true;

                if (isIsolated && isolateSet && !isolateSet.has(id)) visible = false;

                const type = getTypeFromNode(n);
                if (visible && viewFilters[type] === false) visible = false;
                if (visible && viewFilters.onlyOrphans && degreeMap[id] > 0) visible = false;

                if (visible) visibleNodeIds.add(id);
            });
        }

        const viewNodesArr = [];
        nodesData.get().forEach(function(n) {
            if (!visibleNodeIds.has(n.id)) return;
            const t = getTypeFromNode(n);
            const info = TYPE_INFO[t] || {};
            const baseColor = n.baseColor || n.color || info.color || 'gray';
            const obj = {
                id: n.id,
                label: n.label,
                rawLabel: n.rawLabel,
                type: t,
                level: info.level,
                baseColor: baseColor,
                color: baseColor
            };
            viewNodesArr.push(obj);
        });

        if (currentSortMethod === 'alpha') {
            applyAlphaLayout(viewNodesArr);
        }

        const viewEdgesArr = [];
        edgesData.get().forEach(function(e) {
            if (visibleNodeIds.has(e.from) && visibleNodeIds.has(e.to)) {
                viewEdgesArr.push({
                    id: e.id,
                    from: e.from,
                    to: e.to,
                    color: e.color || '#666666'
                });
            }
        });

        updateCounts(degreeMap);
        drawNetwork(viewNodesArr, viewEdgesArr);
        updateBlinking(degreeMap, visibleNodeIds);
    }

    // --- Isolate & focus -------------------------------------------------

    function isolateSelectedNode() {
        if (!selectedNodeId) {
            alert('Select a node in the graph first.');
            return;
        }
        const startId = selectedNodeId;
        const startNode = nodesData.get(startId);
        if (!startNode) {
            alert('Selected node not found.');
            return;
        }

        const startType = getTypeFromNode(startNode);
        const config = TYPE_ISOLATION_CONFIG[startType] || { up: 3, down: 3 };

        const upAdj = {};
        const downAdj = {};
        nodesData.get().forEach(function(n) {
            upAdj[n.id] = new Set();
            downAdj[n.id] = new Set();
        });
        edgesData.get().forEach(function(e) {
            if (downAdj[e.from]) downAdj[e.from].add(e.to);
            if (upAdj[e.to])     upAdj[e.to].add(e.from);
        });

        const set = new Set();
        set.add(startId);

        if (config.up > 0) {
            const visitedUp = new Set([startId]);
            const queueUp = [{ id: startId, depth: 0 }];
            while (queueUp.length) {
                const current = queueUp.shift();
                const id = current.id;
                const depth = current.depth;
                if (depth >= config.up) continue;
                (upAdj[id] || []).forEach(function(parentId) {
                    if (!visitedUp.has(parentId)) {
                        visitedUp.add(parentId);
                        set.add(parentId);
                        queueUp.push({ id: parentId, depth: depth + 1 });
                    }
                });
            }
        }

        if (config.down > 0) {
            const visitedDown = new Set([startId]);
            const queueDown = [{ id: startId, depth: 0 }];
            while (queueDown.length) {
                const current = queueDown.shift();
                const id = current.id;
                const depth = current.depth;
                if (depth >= config.down) continue;
                (downAdj[id] || []).forEach(function(childId) {
                    if (!visitedDown.has(childId)) {
                        visitedDown.add(childId);
                        set.add(childId);
                        queueDown.push({ id: childId, depth: depth + 1 });
                    }
                });
            }
        }

        isIsolated = true;
        isolateSet = set;
        isolatedNodeId = startId;

        focusMode = false;
        focusType = null;
        focusNodeId = null;

        applyVisibility();
    }

    function focusNeighbors() {
        if (!selectedNodeId) {
            alert('Select a node in the graph first.');
            return;
        }
        const node = nodesData.get(selectedNodeId);
        if (!node) {
            alert('Selected node not found.');
            return;
        }
        const t = getTypeFromNode(node);
        if (!TYPE_INFO[t]) {
            alert('Unknown node type for focus.');
            return;
        }

        focusMode = true;
        focusType = t;
        focusNodeId = selectedNodeId;

        isIsolated = false;
        isolateSet = null;

        // Layer Focus default: alpha sort
        currentSortMethod = 'alpha';
        sortMethodEl.value = 'alpha';

        applyVisibility();
    }

    function showAll() {
        isIsolated = false;
        isolateSet = null;
        isolatedNodeId = null;
        focusMode = false;
        focusType = null;
        focusNodeId = null;
        applyVisibility();
    }

    // --- Edge helpers ----------------------------------------------------

    function handleShiftNodeClick(nodeId) {
        if (!edgeCreationSourceId) {
            edgeCreationSourceId = nodeId;
            if (network) network.selectNodes([nodeId]);
            return;
        }

        if (edgeCreationSourceId === nodeId) {
            edgeCreationSourceId = null;
            if (network) network.selectNodes([]);
            return;
        }

        let fromId = edgeCreationSourceId;
        let toId   = nodeId;
        edgeCreationSourceId = null;
        if (network) network.selectNodes([]);

        const fromNode = nodesData.get(fromId);
        const toNode   = nodesData.get(toId);
        if (!fromNode || !toNode) return;

        const fromType = getTypeFromNode(fromNode);
        const toType   = getTypeFromNode(toNode);

        // Accept either direction, but enforce hierarchical order
        let finalFrom = fromId;
        let finalTo   = toId;

        if (canConnectTypes(fromType, toType)) {
            // ok
        } else if (canConnectTypes(toType, fromType)) {
            finalFrom = toId;
            finalTo   = fromId;
        } else {
            alert('Invalid edge. Edges must connect adjacent layers: Symptom ↔ Root Cause ↔ Capability ↔ Solution.');
            return;
        }

        const existing = edgesData.get({
            filter: function(e) { return e.from === finalFrom && e.to === finalTo; }
        });
        if (existing.length) {
            alert('An edge between these nodes already exists.');
            return;
        }

        edgesData.add({ from: finalFrom, to: finalTo, color: '#666666' });
        isDirty = true;
        refreshNodeSelects();
        applyVisibility();
    }

    function handleEdgeDeleteClick(edgeIds) {
        if (!edgeIds || !edgeIds.length) return;
        if (!confirm('Delete selected edge(s)?')) return;
        edgesData.remove(edgeIds);
        isDirty = true;
        refreshNodeSelects();
        deletePressed = false;
        applyVisibility();
    }

    // --- DOM wiring ------------------------------------------------------

    const importTextEl   = document.querySelector('#causal-editor #importText');
    const importFileEl   = document.querySelector('#causal-editor #importFile');
    const exportTextEl   = document.querySelector('#causal-editor #exportText');

    const selectedNodeIdEl  = document.querySelector('#causal-editor #selectedNodeId');
    const createNodeLabelEl = document.querySelector('#causal-editor #createNodeLabel');
    const createNodeTypeEl  = document.querySelector('#causal-editor #createNodeType');

    const editNodeLabelEl = document.querySelector('#causal-editor #editNodeLabel');
    const editNodeTypeEl  = document.querySelector('#causal-editor #editNodeType');

    const edgeFromEl   = document.querySelector('#causal-editor #edgeFrom');
    const edgeToEl     = document.querySelector('#causal-editor #edgeTo');

    const filterSymptomEl    = document.querySelector('#causal-editor #filterSymptom');
    const filterRootCauseEl  = document.querySelector('#causal-editor #filterRootCause');
    const filterCapabilityEl = document.querySelector('#causal-editor #filterCapability');
    const filterSolutionEl   = document.querySelector('#causal-editor #filterSolution');
    const onlyOrphansEl      = document.querySelector('#causal-editor #onlyOrphans');

    const sortMethodEl       = document.querySelector('#causal-editor #sortMethod');
    const isolateNodeDisplayEl = document.querySelector('#causal-editor #isolateNodeDisplay');

    document.querySelector('#causal-editor #btnImportText').addEventListener('click', function() {
        const text = importTextEl.value || '';
        handleImport(text);
    });

    importFileEl.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(ev) {
            handleImport(ev.target.result || '');
        };
        reader.readAsText(file);
    });

    // Hard-coded import from indeavor.com/causal-model/
    document.querySelector('#causal-editor #btnImportFromWeb').addEventListener('click', function() {
        const url = 'https://www.indeavor.com/causal-model/';
        fetch(url)
            .then(function(resp) {
                if (!resp.ok) {
                    throw new Error('HTTP ' + resp.status + ' ' + resp.statusText);
                }
                return resp.text();
            })
            .then(function(text) {
                handleImport(text);
            })
            .catch(function(err) {
                console.error('Error importing from web:', err);
                alert(
                    'Could not load the current model from web.\n' +
                    'The page must be accessible from the browser and allow cross-origin requests.\n\n' +
                    'Error: ' + err.message
                );
            });
    });

    document.querySelector('#causal-editor #btnClear').addEventListener('click', function() {
        if (!confirm('Clear all nodes and edges?')) return;
        nodesData.clear();
        edgesData.clear();
        isDirty = true;
        selectedNodeId = null;
        clearSelectedNodeInUI();
        refreshNodeSelects();
        exportTextEl.value = '';

        isIsolated = false;
        isolateSet = null;
        isolatedNodeId = null;
        focusMode = false;
        focusType = null;
        focusNodeId = null;

        applyVisibility();
    });

    document.querySelector('#causal-editor #btnExport').addEventListener('click', function() {
        exportDataJs(false);
        isDirty = false;
    });

    document.querySelector('#causal-editor #btnDownloadData').addEventListener('click', function() {
        const code = exportDataJs(true);
        const blob = new Blob([code], { type: 'text/plain' });
        const now = new Date();
        function pad(n) { return String(n).padStart(2, '0'); }
        const filename =
            'data_JS_' +
            now.getUTCFullYear() + '-' +
            pad(now.getUTCMonth() + 1) + '-' +
            pad(now.getUTCDate()) + 'T' +
            pad(now.getUTCHours()) + '-' +
            pad(now.getUTCMinutes()) + '-' +
            pad(now.getUTCSeconds()) + 'Z.txt';

        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        isDirty = false;
    });

    document.querySelector('#causal-editor #btnAddNode').addEventListener('click', function() {
        const label = createNodeLabelEl.value.trim();
        const type  = createNodeTypeEl.value || 'Symptom';
        if (!label) {
            alert('Please enter a label for the node.');
            return;
        }
        const info = TYPE_INFO[type] || TYPE_INFO['Symptom'];
        const id = slugifyLabel(label);
        const rawLabel = label;
        nodesData.add({
            id: id,
            label: wrapLabel(rawLabel),
            rawLabel: rawLabel,
            type: type,
            baseColor: info.color,
            color: info.color,
            level: info.level
        });
        isDirty = true;
        refreshNodeSelects();
        createNodeLabelEl.value = '';
        selectedNodeId = id;
        selectNodeInUI(id);
        applyVisibility();
    });

    document.querySelector('#causal-editor #btnUpdateNode').addEventListener('click', function() {
        if (!selectedNodeId) {
            alert('Select a node in the graph first.');
            return;
        }
        const node = nodesData.get(selectedNodeId);
        if (!node) {
            alert('Selected node not found.');
            return;
        }

        const newRaw = editNodeLabelEl.value.trim() || node.rawLabel || node.label;
        const newType = editNodeTypeEl.value || getTypeFromNode(node);
        const info = TYPE_INFO[newType] || TYPE_INFO['Symptom'];

        // validate type change vs all incident edges
        const incidentEdges = edgesData.get({
            filter: function(e) { return e.from === node.id || e.to === node.id; }
        });
        for (let i = 0; i < incidentEdges.length; i++) {
            const e = incidentEdges[i];
            const otherId = (e.from === node.id) ? e.to : e.from;
            const otherNode = nodesData.get(otherId);
            if (!otherNode) continue;
            const otherType = getTypeFromNode(otherNode);

            let ok;
            if (e.from === node.id) ok = canConnectTypes(newType, otherType);
            else                    ok = canConnectTypes(otherType, newType);

            if (!ok) {
                alert(
                    'Cannot change type: it would create an invalid edge between ' +
                    newType + ' and ' + otherType +
                    '. Remove or adjust those edges first.'
                );
                editNodeTypeEl.value = getTypeFromNode(node);
                return;
            }
        }

        nodesData.update({
            id: node.id,
            label: wrapLabel(newRaw),
            rawLabel: newRaw,
            type: newType,
            baseColor: info.color,
            color: info.color,
            level: info.level
        });

        enforceValidEdges();
        isDirty = true;
        refreshNodeSelects();
        selectNodeInUI(node.id);
        applyVisibility();
    });

    document.querySelector('#causal-editor #btnDeleteNode').addEventListener('click', function() {
        if (!selectedNodeId) {
            alert('Select a node to delete.');
            return;
        }
        if (!confirm('Delete node and all connected edges?')) return;
        const edgesToRemove = edgesData.get({
            filter: function(e) { return e.from === selectedNodeId || e.to === selectedNodeId; }
        }).map(function(e) { return e.id; });
        if (edgesToRemove.length) edgesData.remove(edgesToRemove);
        nodesData.remove(selectedNodeId);
        isDirty = true;
        selectedNodeId = null;
        clearSelectedNodeInUI();
        refreshNodeSelects();
        applyVisibility();
    });

    document.querySelector('#causal-editor #btnAddEdge').addEventListener('click', function() {
        let fromId = edgeFromEl.value;
        let toId   = edgeToEl.value;
        if (!fromId || !toId) {
            alert('Select both From and To nodes.');
            return;
        }
        if (fromId === toId) {
            alert('From and To must be different nodes.');
            return;
        }
        const fromNode = nodesData.get(fromId);
        const toNode   = nodesData.get(toId);
        if (!fromNode || !toNode) {
            alert('Invalid From/To selection.');
            return;
        }
        const fromType = getTypeFromNode(fromNode);
        const toType   = getTypeFromNode(toNode);

        let finalFrom = fromId;
        let finalTo   = toId;

        if (canConnectTypes(fromType, toType)) {
            // ok
        } else if (canConnectTypes(toType, fromType)) {
            finalFrom = toId;
            finalTo   = fromId;
        } else {
            alert('Invalid edge. Edges must connect adjacent layers: Symptom ↔ Root Cause ↔ Capability ↔ Solution.');
            return;
        }

        const existing = edgesData.get({
            filter: function(e) { return e.from === finalFrom && e.to === finalTo; }
        });
        if (existing.length) {
            alert('An edge between these nodes already exists.');
            return;
        }

        edgesData.add({ from: finalFrom, to: finalTo, color: '#666666' });
        isDirty = true;
        refreshNodeSelects();
        applyVisibility();
    });

    document.querySelector('#causal-editor #btnDeleteEdge').addEventListener('click', function() {
        const fromId = edgeFromEl.value;
        const toId   = edgeToEl.value;
        if (!fromId || !toId) {
            alert('Select both From and To nodes to delete edges between them.');
            return;
        }
        const toDelete = edgesData.get({
            filter: function(e) { return e.from === fromId && e.to === toId; }
        }).map(function(e) { return e.id; });
        if (!toDelete.length) {
            alert('No edges found between the selected nodes.');
            return;
        }
        if (!confirm('Delete all edge(s) between the selected nodes?')) return;
        edgesData.remove(toDelete);
        isDirty = true;
        refreshNodeSelects();
        applyVisibility();
    });

    document.querySelector('#causal-editor #btnIsolate').addEventListener('click', isolateSelectedNode);
    document.querySelector('#causal-editor #btnFocusNeighbors').addEventListener('click', focusNeighbors);
    document.querySelector('#causal-editor #btnShowAll').addEventListener('click', showAll);

    filterSymptomEl.addEventListener('change', function() {
        viewFilters['Symptom'] = filterSymptomEl.checked;
        applyVisibility();
    });
    filterRootCauseEl.addEventListener('change', function() {
        viewFilters['Root Cause'] = filterRootCauseEl.checked;
        applyVisibility();
    });
    filterCapabilityEl.addEventListener('change', function() {
        viewFilters['Capability'] = filterCapabilityEl.checked;
        applyVisibility();
    });
    filterSolutionEl.addEventListener('change', function() {
        viewFilters['Solution'] = filterSolutionEl.checked;
        applyVisibility();
    });
    onlyOrphansEl.addEventListener('change', function() {
        viewFilters.onlyOrphans = onlyOrphansEl.checked;
        applyVisibility();
    });

    sortMethodEl.addEventListener('change', function() {
        currentSortMethod = sortMethodEl.value;
        applyVisibility();
    });

    // Only arm deletePressed when Delete/Backspace is pressed outside text fields
    document.addEventListener('keydown', function(e) {
        if ((e.key === 'Delete' || e.key === 'Backspace') &&
            !(e.target && ['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName))) {
            deletePressed = true;
        }
    });
    document.addEventListener('keyup', function(e) {
        if (e.key === 'Delete' || e.key === 'Backspace') {
            deletePressed = false;
        }
    });

    function selectNodeInUI(id) {
        selectedNodeId = id;
        const node = nodesData.get(id);
        if (!node) {
            clearSelectedNodeInUI();
            return;
        }
        selectedNodeIdEl.textContent = id;
        editNodeLabelEl.value = node.rawLabel || node.label || '';
        editNodeTypeEl.value  = getTypeFromNode(node);

        if (isolateNodeDisplayEl) {
            isolateNodeDisplayEl.textContent = node.rawLabel || node.label || id;
        }

        if (!edgeFromEl.value) edgeFromEl.value = id;
    }

    function clearSelectedNodeInUI() {
        selectedNodeId = null;
        selectedNodeIdEl.textContent = 'None';
        if (isolateNodeDisplayEl) isolateNodeDisplayEl.textContent = 'None';
    }

    function refreshNodeSelects() {
        const nodes = nodesData.get().slice().sort(function(a, b) {
            const la = (a.rawLabel || a.label || '').toLowerCase();
            const lb = (b.rawLabel || b.label || '').toLowerCase();
            if (la < lb) return -1;
            if (la > lb) return 1;
            return 0;
        });
        [edgeFromEl, edgeToEl].forEach(function(sel) {
            const current = sel.value;
            sel.innerHTML = '<option value="">-- select --</option>';
            nodes.forEach(function(n) {
                const opt = document.createElement('option');
                opt.value = n.id;
                opt.textContent = n.rawLabel || n.label || n.id;
                sel.appendChild(opt);
            });
            if (current && nodes.some(function(n) { return String(n.id) === current; })) {
                sel.value = current;
            }
        });
    }

    function extractArray(text, kind) {
        const regex = kind === 'nodes'
            ? /window\.nodes\s*=\s*new\s+vis\.DataSet\s*\((\[[\s\S]*?\])\s*\);/
            : /window\.edges\s*=\s*new\s+vis\.DataSet\s*\((\[[\s\S]*?\])\s*\);/;
        const match = regex.exec(text);
        if (!match) return null;
        const arrayCode = match[1];
        try {
            const fn = new Function('return ' + arrayCode + ';');
            const arr = fn();
            if (!Array.isArray(arr)) return null;
            return arr;
        } catch (e) {
            console.error('Error parsing ' + kind, e);
            alert('Error parsing ' + kind + ' array: ' + e.message);
            return null;
        }
    }

    function handleImport(text) {
        const trimmed = (text || '').trim();
        if (!trimmed) {
            alert('Paste your HTML or data.js code first.');
            return;
        }
        const nodesArr = extractArray(trimmed, 'nodes');
        const edgesArr = extractArray(trimmed, 'edges');
        if (!nodesArr || !edgesArr) {
            alert('Could not find window.nodes / window.edges DataSet blocks.\nEnsure you included the data.js section.');
            return;
        }

        const normalizedNodes = nodesArr.map(function(obj) {
            const n = Object.assign({}, obj);
            const type = getTypeFromNode(n);
            const info = TYPE_INFO[type] || {};
            const baseColor = n.color || n.baseColor || info.color || 'gray';
            const rawLabel = n.label || '';
            n.type = type;
            n.baseColor = baseColor;
            n.color = baseColor;
            n.rawLabel = rawLabel;
            n.label = wrapLabel(rawLabel);
            return n;
        });

        const normalizedEdges = edgesArr.map(function(e) {
            return Object.assign({}, e);
        });

        nodesData = new vis.DataSet(normalizedNodes);
        edgesData = new vis.DataSet(normalizedEdges);

        enforceValidEdges();

        selectedNodeId = null;
        isolatedNodeId = null;
        clearSelectedNodeInUI();
        refreshNodeSelects();

        viewFilters = {
            'Symptom': true,
            'Root Cause': true,
            'Capability': true,
            'Solution': true,
            onlyOrphans: false
        };
        filterSymptomEl.checked    = true;
        filterRootCauseEl.checked  = true;
        filterCapabilityEl.checked = true;
        filterSolutionEl.checked   = true;
        onlyOrphansEl.checked      = false;

        isIsolated = false;
        isolateSet = null;
        focusMode = false;
        focusType = null;
        focusNodeId = null;

        // default sort method: directed
        currentSortMethod = 'directed';
        sortMethodEl.value = 'directed';

        isDirty = true;

        applyVisibility();
        alert('Import complete: ' + normalizedNodes.length + ' nodes, ' + normalizedEdges.length + ' edges (invalid edges, if any, removed).');
    }

    function exportDataJs(skipFocus) {
        const nodesArr = nodesData.get().map(function(n) {
            const type = getTypeFromNode(n);
            const info = TYPE_INFO[type] || {};
            const color = n.baseColor || n.color || info.color || 'gray';
            const rawLabel = n.rawLabel || n.label;
            return { id: String(n.id), label: rawLabel, color: color };
        });

        const edgesArr = edgesData.get().map(function(e) {
            return {
                from: String(e.from),
                to: String(e.to),
                color: e.color || '#666666'
            };
        });

        function esc(str) {
            return String(str).replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
        }

        const nodesLines = nodesArr.map(function(n) {
            return "    { id: '" + esc(n.id) + "', label: '" + esc(n.label) + "', color: '" + esc(n.color) + "' }";
        }).join(',\n');

        const edgesLines = edgesArr.map(function(e) {
            return "    { from: '" + esc(e.from) + "', to: '" + esc(e.to) + "', color: '" + esc(e.color) + "' }";
        }).join(',\n');

        const code =
"// --- BEGIN data.js ---\n" +
"window.nodes = new vis.DataSet([\n" +
nodesLines + "\n" +
"]);\n\n" +
"window.edges = new vis.DataSet([\n" +
edgesLines + "\n" +
"]);\n" +
"// --- END data.js ---";

        exportTextEl.value = code;
        if (!skipFocus) {
            exportTextEl.focus();
            exportTextEl.select();
        }
        return code;
    }

    // Warn on tab close / navigation if there are unsaved changes
    window.addEventListener('beforeunload', function(e) {
        if (!isDirty) return;
        e.preventDefault();
        e.returnValue = '';
        return '';
    });

    window.addEventListener('load', function() {
        sortMethodEl.value = 'directed';
        currentSortMethod = 'directed';
        applyVisibility();
    });
</script>
